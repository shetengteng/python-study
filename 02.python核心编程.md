#  核心编程

## 知识扩展

### 关于import导入模块

使用import导入模块的具体路径，查看sys.path

从上到下依次是import导包的路径

```python
In [1]: import sys

In [2]: sys.path
Out[2]: 
['',
 '/usr/bin',
 '/usr/lib/python35.zip',
 '/usr/lib/python3.5',
 '/usr/lib/python3.5/plat-x86_64-linux-gnu',
 '/usr/lib/python3.5/lib-dynload',
 '/usr/local/lib/python3.5/dist-packages',
 '/usr/lib/python3/dist-packages',
 '/usr/lib/python3/dist-packages/IPython/extensions',
 '/home/python/.ipython']
```

如果导入的包不在sys.path中，那么可以在代码中给path添加，如sys.path.append("/home")

```python
sys.path.append("/home/xxx/xxx")
sys.path.insert(0,"/home/xxx/xxx") #这样可以优先处理导入模块
```

#### 重新导入模块

是指当一个py文件使用时，已经使用了，然后该文件被修改了，如何在下面的执行中记载最新的修改的py文件

先定义一个自定义模块test.py

```python
def myTest():
    print("--- my test ---")
```

进行导入操作

```python
import test
from imp import *
test.myTest() # 此时修改test.py文件，那么继续执行test.myTest方法依然是旧的
# 使用重载方式
reload(test)
test.myTest()# 此时执行之后是最新的修改
```

#### 避免循环导入模块

什么是循环导入？

2个py模块互相导入，各自需要对方模块中的方法

如a.py

 ```python
from b import b_func

def a_func():
        print("------ a function ------")
        b_func()

a_func()
 ```

如b.py

```python
from a import a_func

def b_func():
    print("---- b function ----")
   
def c_func():
    a_func()
   
c_func()
```

此时执行a.py 或者b.py 会报错

如何避免循环导入？

1. 程序设计上分层，降低耦合
2. 导入语句放在后面需要导入时再导入，例如放在函数体内导入

### == 与 is

```python
a = [11,22,33]
b = [11,22,33]

a == b # True 判断值是否相等
a is b # False 判断引用是否相等
# 从a 和b 的id可以看出地址是不相同的
id(a)
id(b)

#注意 python和java一样也有int类型的常量池 在[-5, 257)之间的数值
c1 = 100
c2 = 100 
c1 == c2 # True
c1 is c2 # False

c3 = 1000
c4 = 1000
c3 == c4 # True
c3 is c4 # False
```

### 深拷贝与浅拷贝

```python
a = [1,2,3]
b = a # 浅拷贝 只是复制了引用
id(a) 
id(b)
# 两者id相同
```

深拷贝，重新开辟一块内存区域，将内容复制，内容相同，引用地址不同

需要引入copy模块

#### deepcopy方法

```python
import copy
a = [1,2,3]
b = copy.deepcopy(a) # 如果a中包含引用，那么会递归深拷贝
a == b # True
a is b # False
```

对于元组

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.deepcopy(c)
a.append(4)
print(c[0]) # [1,2,3,4]
print(e[0]) # [1,2,3] 说明深度拷贝对于元组来说也是生效的
```

#### copy方法

对于数组而言

```python
a = [1,2,3]
b = [4,5,6]
c = [a,b]
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 但是id(c) 和 id(e) 不相同，说明不是递归的深度拷贝，只深度拷贝一层
id(c) == id(e) # False
```

对于元组而言

```python
a = [1,2,3]
b = [4,5,6]
c = (a,b)
e = copy.copy(c)
a.append(4)
print(c[0])
print(e[0]) # e 和 c 的内容相同 
id(c) == id(e) # True 这里是元组与数组的copy方法时的区别 由于元组是不可变类型，那么copy的时候会判断如果是可变类型，那么就是浅拷贝
```

### 进制转换

```python
bin(10) # 十进制转二进制
Out[14]: '0b1010'
int("1001",2) # 二进制转十进制

hex(10) # 十进制转16进制
‘0xa’
int('ff',16) # 16 进制转 10进制

bin(0xa) # 16 进制转 2进制

oct(9) # 10进制 转 8 进制

hex(0b1001) # 2进制 转 16进制
```

### 位运算

```python
& 按位与
| 按位或
^ 按位异或
~ 按位取反
<< 按位左移
>> 按位右移

用途: 直接操作二进制,省内存,效率高
```

### 私有化

- xx: 公有变量

- _x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问

- __xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)

- __xx__:双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__`, __ 不要自己发明这样的名字

- xx_:单后置下划线,用于避免与Python关键词的冲突

- 通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。 

```python
  如果定义为__xx
  系统会改名称为_Class__xx 因此访问不到 如 t._Test__num 可以访问到
  使用dir查看对象所有名字重整的对象
  如:
  In [16]: dir([1,2])
  Out[16]: 
  ['__add__',
   '__class__',
   '__contains__',
   '__delattr__',
   '__delitem__',
   '__dir__',
   '__doc__',
   '__eq__',
   '__format__',
   '__ge__',
   '__getattribute__',
   '__getitem__',
   '__gt__',
   '__hash__',
   '__iadd__',
   '__imul__',
   '__init__',
   '__iter__',
   '__le__',
   '__len__',
   '__lt__',
   '__mul__',
   '__ne__',
   '__new__',
   '__reduce__',
   '__reduce_ex__',
   '__repr__',
   '__reversed__',
   '__rmul__',
   '__setattr__',
   '__setitem__',
   '__sizeof__',
   '__str__',
   '__subclasshook__',
   'append',
   'clear',
   'copy',
   'count',
   'extend',
   'index',
   'insert',
   'pop',
   'remove',
   'reverse',
   'sort']
```

### 类的属性property

####   私有属性添加getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
```

#### 使用property升级getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    def getMoney(self):
        return self.__money

    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
    money = property(getMoney, setMoney)
   
In [2]: a = Money()
In [3]: a.money
Out[3]: 0
In [4]: a.money = 100
In [5]: a.money
Out[5]: 100
In [6]: a.getMoney()
Out[6]: 100
```

#### 使用@property取代getter和setter方法

- `@property`成为属性函数，可以对属性赋值时做必要的检查，并保证代码的清晰短小，主要有2个作用
  - 将方法转换为只读
  - 重新实现一个属性的设置和读取方法,可做边界判定

```python
class Money(object):
    def __init__(self):
        self.__money = 0

    @property
    def money(self):
        return self.__money

    @money.setter
    def money(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
            
In [3]: a = Money()
In [4]: a.money
Out[4]: 0
In [5]: a.money = 100
In [6]: a.money
Out[6]: 100
```

### 生成器

什么是生成器？

用于生成列表，与列表推导式功能相似，不同在于，如：

a = [x*2 for x in range(10000000)] 此时生成的列表过大，占用内存过多

而使用生成器生成列表则是在使用到这个元素时依次生成，而非一次性生成，解决了性能问题

如何使用？

#### 简单使用生成器

```python
b = (x*2 for x in range(10))
#此时b是一个生成器对象
# 生成一个值，依次生成，使用next(b) 获取
next(b)
# 如果到生成器的极限值则会抛出异常
StopIteration Traceback (most recent call last)
<ipython-input-25-641a931447e8> in <module>()
----> 1 next(b)
```

生成器保存的是算法，每次调用 next(G) ，就计算出 G 的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的异常。当然，这种不断调用 next() 实在是太变态了，正确的方法是使用 for 循环，因为生成器也是可迭代对象。所以，我们创建了一个生成器后，基本上永远不会调用 next() ，而是通过 for 循环来迭代它，并且不需要关心 StopIteration 异常 

#### 创建生成器-yield（产生）

添加了yield修饰符的函数就是一个生成器

示例：斐波拉契数列 1、1、2、3、5、8、13、21  F(n) = F(n-1)+F(n-2) 使用生成器实现

```python
def createNum():
	print("---start---")
	a,b = 0,1
	for i in range(6):
		print("---1---")
		yield b # 将b作为生成器每次生成的结果输出
		print("---2---")
		a,b = b,a+b
		print("---3---")
	print("---end---")   
 
# 注意观察执行顺序
In [8]: from test import *
In [9]: b = createNum()
In [10]: b
Out[10]: <generator object createNum at 0x7f1f3d3db8e0>
In [11]: next(b)
---start---
---1---
Out[11]: 1
In [12]: next(b)
---2---
---3---
---1---
Out[12]: 1
In [13]: next(b)
---2---
---3---
---1---
Out[13]: 2
```

使用生成器

```python
# 可以直接使用for循环进行输出
In [14]: for x in createNum():
   ....:     print(x) 
---start---
---1---
1
---2---
---3---
---1---
1
---2---
---3---
---1---
2
---2---
---3---
---1---
3
---2---
---3---
---1---
5
---2---
---3---
---1---
8
---2---
---3---
---end---
# 也可以使用while循环，不过要对异常进行捕获
f = createNum()
while(true):
    try:
        print(next(f))
    except StopIteration as e:
        break  
```

#### send() 方法

返回值同next调用，不同的是可以传参给生成器，传参的位置是yield 声明的地方

下次执行时，可以将上次的传参带入函数中执行

```python
In [10]: def gen():
   ....:     i = 0
   ....:     while i<5:
   ....:         temp = yield i
   ....:         print(temp)
   ....:         i+=1
```

#### `__next__()`方法

```python
# 如F是一个生成器对象
next(F)
# 执行生成器 同上个方法
F.__next__()
```

生成器的特点：

1. 节约内存
2. 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的

多任务执行示例：协程处理

```python
In [15]: def test1():
   ....:     while True:
   ....:         print("----1---")
   ....:         yield None
   ....:         

In [16]: def test2():
   ....:     while True:
   ....:         print("----2----")
   ....:         yield None
   ....:         

In [17]: t1 = test1()

In [18]: t2 = test2()

In [19]: while True:
   ....:     t1.__next__()
   ....:     t2.__next__()
    
   # 输出是2个while循环协同执行
```

### 迭代器

适用类型：

​	集合类数据类型 ，list、tuple、dict、set、str

​	generator的子类，包括生成器以及带yield的generator的function

可以直接使用for循环的对象

#### 判断是否可以迭代

使用isinstance()判断一个对象是否是Iterable对象

```python
In [1]: from collections import Iterable
In [2]: isinstance([],Iterable)
Out[2]: True
In [3]: isinstance('abc',Iterable)
Out[3]: True
In [4]: isinstance({},Iterable)
Out[4]: True
In [6]: isinstance((x for x in range(10)),Iterable)
Out[6]: True
```

#### 判断是否是迭代器

可以被next()调用的并不断返回下一个值的对象 为迭代器 Iterator

使用isinstance() 判断一个对象是否是Iterator对象

```python
In [20]: from collections import Iterator
In [21]: isinstance([],Iterator)
Out[21]: False
In [22]: isinstance((x for x in range(10)),Iterator)
Out[22]: True
```

#### iter() 方法：把Iterable对象转换成Iterator对象

生成器都是Iterator对象，但是list dict str 虽然是Iterable 但不是Iterator

```python
In [23]: from collections import Iterator
In [24]: isinstance(iter([]),Iterator)
Out[24]: True
```

总结：

- 凡是可作用于 for 循环的对象都是 Iterable 类型；
- 凡是可作用于 next() 函数的对象都是 Iterator 类型
- 集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象

### 闭包

 函数引用：同js一样 函数可以通过引用的方式传参和调用 ，可以将函数看成一个对象

```python
def test1():
    print("--- in test1 func----")

#调用函数
test1()
#引用函数
ret = test1
print(id(ret))
print(id(test1))
#通过引用调用函数
ret()
```

什么是闭包？

- 内部函数使用外部函数的参数
- 外部函数返回值是内部函数的引用

```python
#定义一个函数
def test(number):

    #在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包
    def test_in(number_in):
        print("in test_in 函数, number_in is %d"%number_in)
        return number+number_in
    #其实这里返回的就是闭包的结果
    return test_in

#给test函数赋值，这个20就是给参数number
ret = test(20)
#注意这里的100其实给参数number_in
print(ret(100))
#注意这里的200其实给参数number_in
print(ret(200))
```

 示例：

```python
def line_conf(a, b):
    def line(x):
        return a*x + b
    return line

line1 = line_conf(1, 1)
line2 = line_conf(4, 5)
print(line1(5))
print(line2(5))
```

函数line与变量a,b构成闭包。在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个变量的取值，这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。我们只需要变换参数a,b，就可以获得不同的直线表达函数。由此，我们可以看到，闭包也具有提高代码可复用性的作用 

如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。这样，我们就需要更多的参数传递，也减少了代码的可移植性 

```
1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成
2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放
```

### 装饰器

python的语法糖

符合开放封闭原则，对扩展开放，对已有功能封闭

装饰器：给原有的方法添加其他功能，类似于java中的代理

```python
def w1(func): # 外部传入的函数引用，供给闭包调用
    def inner(): # 固定写法 inner 的闭包
        # 验证1
        # 验证2
        # 验证3
        if True:
            func()
        else:
            print("没有权限")
    return inner

@w1
def f1():
    print('f1')
@w1
def f2():
    print('f2')
@w1
def f3():
    print('f3')
@w1
def f4():
    print('f4')
    
# 语法糖写法    
# @w1 等价于 f1 = w1(f1)
```

示例：2个装饰器，注意执行的顺序于书写的顺序一致，层层嵌套，从上往下装饰，从下往上调用

```python
#定义函数：完成包裹数据
def makeBold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped

#定义函数：完成包裹数据
def makeItalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped

@makeBold
def test1():
    return "hello world-1"

@makeItalic
def test2():
    return "hello world-2"

@makeBold
@makeItalic
def test3():
    return "hello world-3"

print(test1())
print(test2())
print(test3())
# 结果
<b>hello world-1</b>
<i>hello world-2</i> 
<b><i>hello world-3</i></b>
```

应用场景：

1. 引入日志
2. 函数执行时间统计
3. 执行函数前预备处理
4. 执行函数后清理功能
5. 权限校验等场景
6. 缓存

装饰器执行的时间：

​	只要py代码解释到了@w1这句，那么就会自动执行装饰，等价于执行 f1 = w1(f1)

​	而不是要等到调用的时候才执行



#### 无参数函数装饰

```python
def func(funcName):
    print("---func----")
    def func_in():
        print("----func in----")
        funcName()
        print("----funcName----")

    print("----func 2---")
    return func_in

@func
def test():
    print("---test---")

#test = func(test)
test()
# 结果：
---func----
----func 2---
----func in----
---test---
----funcName----
```

示例：

```python
from time import ctime, sleep

def timefun(func):
    def wrappedfunc():
        print("%s called at %s"%(func.__name__, ctime()))
        func()
    return wrappedfunc

@timefun
def foo():
    print("I am foo")

foo()
sleep(2)
foo()
```



#### 有参数函数装饰

```python
from time import ctime,sleep

def timefun(func):
    def wrappedfunc(a,b):
        print("%s called at %s"%(func.__name__,ctime()))
        print(a,b)
        func(a,b)

    return wrappedfunc

@timefun
def test(a,b):
    print(a+b)

test(2,3)
```



#### 不定长参数函数装饰

```python
from time import ctime, sleep

def timefun(func):
    def wrappedfunc(*args, **kwargs):
        print("%s called at %s"%(func.__name__, ctime()))
        func(*args, **kwargs)
    return wrappedfunc

@timefun
def foo(a, b, c):
    print(a+b+c)

foo(3,5,7)
sleep(2)
foo(2,4,9)
```



#### 含有返回值的函数装饰

```python
from time import ctime,sleep

def timefun(func):
    def wrappedfunc(a,b):
        print("%s called at %s"%(func.__name__,ctime()))
        print(a,b)
        return func(a,b) # 对于有返回值的，这里需要进行返回操作

    return wrappedfunc

@timefun
def test(a,b):
    return (a+b)

print(test(2,3))
```

通用的装饰器是不定长参数和含有返回值装饰结合在一起

#### 装饰器中传参

在原有装饰器的基础上，设置外部变量，使用双层嵌套闭包实现

```python
from time import ctime,sleep

def time_arg(param="type1"):
	def time_func(func):
		def wrapped_func():
			if (param == "type1"):
				print("%s called at %s %s"%(func.__name__,ctime(),param))
			elif (param == "type2"):
				print("type2----")
			elif (param == "type3"):
				print("type3----")
			else:
				print("unknown")
			func()
		return wrapped_func
	return time_func

@time_arg("type3")
def foo1():
    print("foo1----")

@time_arg() # 注意是缺省值需要有一个大括号来表示
def foo2():
    print("foo2---")

foo1()
foo2()
# 本质上 @time_arg 等价于 foo1 = time_arg("type3")(foo1)
```

#### 类装饰器

装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 `__call__()` 方法，那么这个对象就是callable的

```python
class Test():
    def __call__(self):
        print('call me!')

t = Test()
t()  # call me
```

示例：注意`__call__`的调用

```python
class Test(object):
    def __init__(self, func):
        print("---初始化---")
        print("func name is %s"%func.__name__)
        self.__func = func
    def __call__(self):
        print("---装饰器中的功能---")
        self.__func()
#说明：
#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象
#    并且会把test这个函数名当做参数传递到__init__方法中
#    即在__init__方法中的func变量指向了test函数体
#
#2. test函数相当于指向了用Test创建出来的实例对象
#
#3. 当在使用test()进行调用时，就相当于让这个对象()，因此会调用这个对象的__call__方法
#
#4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用
#    所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体
@Test
def test():
    print("----test---")
test()
showpy()#如果把这句话注释，重新运行程序，依然会看到"--初始化--"

### 结果
---初始化---
func name is test
---装饰器中的功能---
----test---
```



### 作用域

#### locals

查看局部变量信息

```python
locals()
```

#### globals

查看当前的所有全局变量，在python3和ipython3中的显示内容有所区别

```python
In [2]: globals()
Out[2]: 
{'_iii': '',
 '__spec__': None,
 '_sh': <module 'IPython.core.shadowns' from '/usr/lib/python3/dist-packages/IPython/core/shadowns.py'>,
 'quit': <IPython.core.autocall.ExitAutocall at 0x7ff28309c518>,
 'In': ['', 'globals', 'globals()'],
 '__name__': '__main__',
 '_ih': ['', 'globals', 'globals()'],
 '_i': 'globals',
 '__loader__': None,
 'exit': <IPython.core.autocall.ExitAutocall at 0x7ff28309c518>,
 'Out': {1: <function globals>},
 '__': '',
 '__doc__': 'Automatically created module for IPython interactive environment',
 '_': <function globals>,
 '_1': <function globals>,
 '__builtin__': <module 'builtins' (built-in)>,
 '_oh': {1: <function globals>},
 '_ii': '',
 '_i1': 'globals',
 '_dh': ['/home/python/Desktop/python-study/pro'],
 'get_ipython': <bound method InteractiveShell.get_ipython of <IPython.terminal.interactiveshell.TerminalInteractiveShell object at 0x7ff285563358>>,
 '__package__': None,
 '__builtins__': <module 'builtins' (built-in)>,
 '_i2': 'globals()',
 '___': ''}
```

#### LEGB 规则

Python 使用 LEGB 的顺序来查找一个符号对应的对象 

```python
locals -> enclosing function -> globals -> builtins
```

locals，当前所在命名空间（如函数、模块），函数的参数也属于命名空间内的变量enclosing，外部嵌套函数的命名空间（闭包中常见）

```
def fun1():
  a = 10
  def fun2():
      # a 位于外部嵌套函数的命名空间
      print(a)
```

globals，全局变量，函数定义所在模块的命名空间

```
a = 1
def fun():
  # 需要通过 global 指令来声明全局变量
  global a
  # 修改全局变量，而不是创建一个新的 local 变量
  a = 2
```

builtins，内建模块的命名空间 

```
  Python 在启动的时候会自动为我们载入很多内建的函数、类，
  比如 dict，list，type，print，这些都位于 __builtin__ 模块中，
  可以使用 dir(__builtin__) 来查看。
  这也是为什么我们在没有 import任何模块的情况下，
  就能使用这么多丰富的函数和功能了。

  在Python中，有一个内建模块，该模块中有一些常用函数;在Python启动后，
  且没有执行程序员所写的任何代码前，Python会首先加载该内建函数到内存。
  另外，该内建模块中的功能可以直接使用，不用在其前添加内建模块前缀，
  其原因是对函数、变量、类等标识符的查找是按LEGB法则，其中B即代表内建模块
  比如：内建模块中有一个abs()函数，其功能求绝对值，如abs(-20)将返回20。
```



### 动态添加属性和方法

动态编程语言定义：

`动态编程语言` 是 `高级程序设计语言` 的一个类别，在计算机科学领域已被广泛应用。它是一类 在`运行时可以改变其结构`的语言 ：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。动态语言目前非常具有活力。例如JavaScript便是一个动态语言，除此之外如 PHP 、 Ruby 、 Python 等也都属于动态语言，而 C 、 C++ 等语言则不属于动态语言 

#### 在创建对象后添加属性和方法

```python
import types

#定义了一个类
class Person(object):
    num = 0
    def __init__(self, name = None, age = None):
        self.name = name
        self.age = age
    def eat(self):
        print("eat food")

#定义一个实例方法
def run(self, speed):
    print("%s在移动, 速度是 %d km/h"%(self.name, speed))

#定义一个类方法
@classmethod
def testClass(cls):
    cls.num = 100

#定义一个静态方法
@staticmethod
def testStatic():
    print("---static method----")

#创建一个实例对象
P = Person("老王", 24)
#调用在class中的方法
P.eat()

#给这个对象添加实例方法 
#注意：该方法的作用是将P作为参数传入run方法的self中，并返回一个传入该P对象的方法引用，猜测这里也是闭包实现的
P.run = types.MethodType(run, P)
#调用实例方法
P.run(180)

#给Person类绑定类方法
Person.testClass = testClass
#调用类方法
print(Person.num)
Person.testClass()
print(Person.num)

#给Person类绑定静态方法
Person.testStatic = testStatic
#调用静态方法
Person.testStatic()
```

#### 删除属性和方法

1.del 对象.属性名

2.delattr(对象, "属性名")

通过以上例子可以得出一个结论：相对于动态语言，静态语言具有严谨性！所以，玩动态语言的时候，小心动态的坑！那么怎么避免这种情况呢？ 请使用`__slots__`

#### 限制动态添加属性(slots)

使用`__slots__`限定属性成员对象后，再动态添加属性后会报错

```python
>>> class Person(object):
    __slots__ = ("name", "age")

>>> P = Person()
>>> P.name = "老王"
>>> P.age = 20
>>> P.score = 100
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
AttributeError: Person instance has no attribute 'score'
>>>
```

注意：`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的

### 元类

在orm的框架中使用到，类似于java中的反射使用的meta-class

类也是对象。在java中通过类加载器按需加载类对象，在python中类也是一个对象

可以对类对象进行如下操作：

1. 将它赋值给一个变量
2. 可以拷贝它
3. 可以为它增加属性
4. 可以将它作为函数参数进行传递

```python
>>> print ObjectCreator     # 你可以打印一个类，因为它其实也是一个对象
<class '__main__.ObjectCreator'>
>>> def echo(o):
…       print o
…
>>> echo(ObjectCreator)                 # 你可以将类做为参数传给函数
<class '__main__.ObjectCreator'>
>>> print hasattr(ObjectCreator, 'new_attribute')
Fasle
>>> ObjectCreator.new_attribute = 'foo' #  你可以为类增加属性
>>> print hasattr(ObjectCreator, 'new_attribute')
True
>>> print ObjectCreator.new_attribute
foo
>>> ObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量
>>> print ObjectCreatorMirror()
<__main__.ObjectCreator object at 0x8997b4c>
```

#### 使用class动态创建类

等价于将类对象作为值返回

```python
>>> def choose_class(name):
…       if name == 'foo':
…           class Foo(object):
…               pass
…           return Foo     # 返回的是类，不是类的实例
…       else:
…           class Bar(object):
…               pass
…           return Bar
…
>>> MyClass = choose_class('foo')
>>> print MyClass              # 函数返回的是类，不是类的实例
<class '__main__'.Foo>
>>> print MyClass()            # 你可以通过这个类创建类实例，也就是对象
<__main__.Foo object at 0x89c6d4c>
```

#### 使用type动态创建类

type的一般用法

```python
>>> print type(1) #数值的类型
<type 'int'>
>>> print type("1") #字符串的类型
<type 'str'>
>>> print type(ObjectCreator()) #实例对象的类型
<class '__main__.ObjectCreator'>
>>> print type(ObjectCreator) #类的类型
<type 'type'>
```

python为了保持向后兼容性，可以动态的创建类 type(参数一，参数二，参数三)

参数一：类名称

参数二：父类

参数三：创建类的属性以及方法

```python
Test2 = type("Test2",(),{}) #定了一个Test2类
In [5]: Test2() #创建了一个Test2类的实例对象
Out[5]: <__main__.Test2 at 0x10d406b38>
```

##### 创建带有属性的类

注意：这里的属性是类属性

```python
Foo = type('Foo', (), {'bar':True})
```

等价于

```python
class Foo(object):
     bar = True
```

##### 创建带有方法的类

添加实例方法

```python
In [46]: def echo_bar(self): #定义了一个普通的函数
    ...:     print(self.bar)
    ...:
#让FooChild类中的echo_bar属性，指向了上面定义的函数
In [47]: FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar}) 
#判断Foo类中，是否有echo_bar这个属性
In [48]: hasattr(Foo, 'echo_bar')
Out[48]: False
#判断FooChild类中，是否有echo_bar这个属性
In [49]: hasattr(FooChild, 'echo_bar') 
Out[49]: True
In [50]: my_foo = FooChild()
In [51]: my_foo.echo_bar()
True
```

添加静态方法

```python
In [36]: @staticmethod
    ...: def testStatic():
    ...:     print("static method ....")
    ...:
In [37]: Foochild = type('Foochild', (Foo,), {"echo_bar":echo_bar, "testStatic":
    ...: testStatic})

In [38]: fooclid = Foochild()
In [39]: fooclid.testStatic
Out[39]: <function __main__.testStatic>
In [40]: fooclid.testStatic()
static method ....
In [41]: fooclid.echo_bar()
True
```

添加类方法

```python
In [42]: @classmethod
    ...: def testClass(cls):
    ...:     print(cls.bar)
In [43]: Foochild = type('Foochild', (Foo,), {"echo_bar":echo_bar, "testStatic":
    ...: testStatic, "testClass":testClass})
In [44]: fooclid = Foochild()
In [45]: fooclid.testClass()
True
```

#### `__metaclass__`属性

你可以在定义一个类的时候为其添加__metaclass__属性。

```
class Foo(object):
    __metaclass__ = something…
    ...省略...
```

如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :

```
class Foo(Bar):
    pass
```

Python做了如下的操作：

1. Foo中有__metaclass__这个属性吗？如果是，Python会通过__metaclass__创建一个名字为Foo的类(对象)
2. 如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。
3. 如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。
4. 如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。

现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以

#### 自定义元类

元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。

假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。

幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类。所以，我们这里就先以一个简单的函数作为例子开始。

##### python2中

```
#-*- coding:utf-8 -*-
def upper_attr(future_class_name, future_class_parents, future_class_attr):

    #遍历属性字典，把不是__开头的属性名字变为大写
    newAttr = {}
    for name,value in future_class_attr.items():
        if not name.startswith("__"):
            newAttr[name.upper()] = value

    #调用type来创建一个类
    return type(future_class_name, future_class_parents, newAttr)

class Foo(object):
    __metaclass__ = upper_attr #设置Foo类的元类为upper_attr
    bar = 'bip'

print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)
```

##### python3中

```
#-*- coding:utf-8 -*-
def upper_attr(future_class_name, future_class_parents, future_class_attr):

    #遍历属性字典，把不是__开头的属性名字变为大写
    newAttr = {}
    for name,value in future_class_attr.items():
        if not name.startswith("__"):
            newAttr[name.upper()] = value

    #调用type来创建一个类
    return type(future_class_name, future_class_parents, newAttr)

class Foo(object, metaclass=upper_attr):
    bar = 'bip'

print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)
```

现在让我们再做一次，这一次用一个真正的class来当做元类。

```
#coding=utf-8

class UpperAttrMetaClass(type):
    # __new__ 是在__init__之前被调用的特殊方法
    # __new__是用来创建对象并返回之的方法
    # 而__init__只是用来将传入的参数初始化给对象
    # 你很少用到__new__，除非你希望能够控制对象的创建
    # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__
    # 如果你希望的话，你也可以在__init__中做些事情
    # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用
    def __new__(cls, future_class_name, future_class_parents, future_class_attr):
        #遍历属性字典，把不是__开头的属性名字变为大写
        newAttr = {}
        for name,value in future_class_attr.items():
            if not name.startswith("__"):
                newAttr[name.upper()] = value

        # 方法1：通过'type'来做类对象的创建
        # return type(future_class_name, future_class_parents, newAttr)

        # 方法2：复用type.__new__方法
        # 这就是基本的OOP编程，没什么魔法
        # return type.__new__(cls, future_class_name, future_class_parents, newAttr)

        # 方法3：使用super方法
        return super(UpperAttrMetaClass, cls).__new__(cls, future_class_name, future_class_parents, newAttr)

#python2的用法
class Foo(object):
    __metaclass__ = UpperAttrMetaClass
    bar = 'bip'

# python3的用法
# class Foo(object, metaclass = UpperAttrMetaClass):
#     bar = 'bip'

print(hasattr(Foo, 'bar'))
# 输出: False
print(hasattr(Foo, 'BAR'))
# 输出:True

f = Foo()
print(f.BAR)
# 输出:'bip'
```

就是这样，除此之外，关于元类真的没有别的可说的了。但就元类本身而言，它们其实是很简单的：

1. 拦截类的创建
2. 修改类
3. 返回修改之后的类



### 垃圾回收

小整数对象池：[-5,256] 范围内的整数常驻内存，用于快速访问，减少垃圾回收时申请和销毁内存空间，单个字母也有对象池，当2个相同的字符串引用计数为0，触发垃圾回收，超过该范围的数字对象则会开辟一个空间，生成一个新的对象

intern机制：对新输入的字符串作为一个对象存储，同样内容的字符串则不会新创建，如果

引用计数为0则释放，注意这里的字符串是指的是没有特殊字符分割的字符串，如果有特字符分割，那么每次创建的都是新的对象

```python
In [3]: a = "hh"
In [4]: id(a)
Out[4]: 140679566345304
In [5]: b = "hh"
In [6]: id(b)
Out[6]: 140679566345304
In [7]: c = "jj dd"
In [8]: d = "jj dd"
In [9]: id(c)
Out[9]: 140679539105440
In [10]: id(d)
Out[10]: 140679539105664
```

#### GC机制

python采用引进计数机制为主，标记清除和分代收集为辅的策略

##### 引用计数机制

在python中的每个对象核心是一个结构体PyObject

```python
typedef struct_object{
    int obj_refcnt;
    struct_typeobject *ob_type;
}PyObject;
```

每次调用，obj_refcnt进行计数，对象删除则会减少

优点：

- 简单
- 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时 

缺点：

- 维护引用计数消耗资源

- 循环引用 : list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收 

 ```python
  list1 = []
  list2 = []
  list1.append(list2)
  list2.append(list1)
 ```

##### 标记清除

英文原文: [visualizing garbage collection in ruby and python](http://patshaughnessy.net/2013/10/24/visualizing-garbage-collection-in-ruby-and-python) 

Python中的垃圾回收是以引用计数为主，分代收集为辅。

#### GC模块使用

导致引用计数+1的情况

- `对象被创建，例如a=23`
- `对象被引用，例如b=a`
- `对象被作为参数，传入到一个函数中，例如func(a)`
- `对象作为一个元素，存储在容器中，例如list1=[a,a]`

导致引用计数-1的情况

- `对象的别名被显式销毁，例如del a`
- `对象的别名被赋予新的对象，例如a=24`
- `一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）`
- `对象所在的容器被销毁，或从容器中删除对象`

##### 查看一个对象的引用计数

```python
import sys
a = "hello world"
sys.getrefcount(a)
```

可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1

##### 循环引用导致内存泄露

引用计数的缺陷是循环引用的问题

```python
import gc

class ClassA():
    def __init__(self):
        print('object born,id:%s'%str(hex(id(self))))

def f2():
    while True:
        c1 = ClassA()
        c2 = ClassA()
        c1.t = c2
        c2.t = c1
        del c1
        del c2

#把python的gc关闭
gc.disable()

f2()
```

执行f2()，进程占用的内存会不断增大。

- 创建了c1，c2后这两块内存的引用计数都是1，执行`c1.t=c2`和`c2.t=c1`后，这两块内存的引用计数变成2.
- 在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2，在del c2后，同理，内存1的对象，内存2的对象的引用数都是1。
- 虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

##### 垃圾回收

```python
#coding=utf-8
import gc

class ClassA():
    def __init__(self):
        print('object born,id:%s'%str(hex(id(self))))
    # def __del__(self):
    #     print('object del,id:%s'%str(hex(id(self))))

def f3():
    print("-----0------")
    # print(gc.collect())
    c1 = ClassA()
    c2 = ClassA()
    c1.t = c2
    c2.t = c1
    print("-----1------")
    del c1
    del c2
    print("-----2------")
    print(gc.garbage)
    print("-----3------")
    print(gc.collect()) #显式执行垃圾回收
    print("-----4------")
    print(gc.garbage)
    print("-----5------")

if __name__ == '__main__':
    gc.set_debug(gc.DEBUG_LEAK) #设置gc模块的日志
    f3()
```

python2运行结果:

```python
-----0------
object born,id:0x724b20
object born,id:0x724b48
-----1------
-----2------
[]
-----3------
gc: collectable <ClassA instance at 0x724b20>
gc: collectable <ClassA instance at 0x724b48>
gc: collectable <dict 0x723300>
gc: collectable <dict 0x71bf60>
4
-----4------
[<__main__.ClassA instance at 0x724b20>, <__main__.ClassA instance at 0x724b48>, {'t': <__main__.ClassA instance at 0x724b48>}, {'t': <__main__.ClassA instance at 0x724b20>}]
-----5------
```

说明:

- 垃圾回收后的对象会放在gc.garbage列表里面
- gc.collect()会返回不可达的对象数目，4等于两个对象以及它们对应的dict

有三种情况会触发垃圾回收：

1. 调用gc.collect(),
2. 当gc模块的计数器达到阀值的时候。
3. 程序退出的时候

##### 常用函数

`gc模块提供一个接口给开发者设置垃圾回收的选项`。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。

1、gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK

2、gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。 返回不可达（unreachable objects）对象的数目

3、gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率。

4、gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率。

5、gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表

##### 自动回收机制

必须要import gc模块，并且`is_enable()=True`才会启动自动垃圾回收。

这个机制的`主要作用就是发现并处理不可达的垃圾对象`。

`垃圾回收=垃圾检查+垃圾回收`

在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。

gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。

例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如：

```python
print gc.get_count() # (590, 8, 0)
a = ClassA()
print gc.get_count() # (591, 8, 0)
del a
print gc.get_count() # (590, 8, 0)
```

3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。

gc模快有一个自动垃圾回收的`阀值`，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10) 每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器

例如，假设阀值是(700,10,10)：

```
当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)
当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)
当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)
```

###### 注意点

gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法

```python
import gc

class ClassA():
    pass
    # def __del__(self):
    #     print('object born,id:%s'%str(hex(id(self))))

gc.set_debug(gc.DEBUG_LEAK)
a = ClassA()
b = ClassA()

a.next = b
b.prev = a

print "--1--"
print gc.collect()
print "--2--"
del a
print "--3--"
del b
print "--3-1--"
print gc.collect()
print "--4--"
```

运行结果：

```python
--1--
0
--2--
--3--
--3-1--
gc: collectable <ClassA instance at 0x21248c8>
gc: collectable <ClassA instance at 0x21248f0>
gc: collectable <dict 0x2123030>
gc: collectable <dict 0x2123150>
4
--4--
```

如果把**del**打开，运行结果为:

```python
--1--
0
--2--
--3--
--3-1--
gc: uncollectable <ClassA instance at 0x6269b8>
gc: uncollectable <ClassA instance at 0x6269e0>
gc: uncollectable <dict 0x61bed0>
gc: uncollectable <dict 0x6230c0>
4
--4--
```

### 内建属性

```python
In [11]: class Person():
   ....:     pass
In [12]: dir(Person)
Out[12]: 
['__class__',
 '__delattr__',
 '__dict__',
 '__dir__',
 '__doc__',
 '__eq__',
 '__format__',
 '__ge__',
 '__getattribute__',
 '__gt__',
 '__hash__',
 '__init__',
 '__le__',
 '__lt__',
 '__module__',
 '__ne__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__']
```

| 常用专有属性       | 说明                  | 触发方式                             |
| ------------------ | --------------------- | ------------------------------------ |
| `__init__`         | 构造初始化函数        | 创建实例后,赋值时使用,在`__new__`后  |
| `__new__`          | 生成实例所需属性      | 创建实例时                           |
| `__class__`        | 实例所在的类          | 实例.`__class__`                     |
| `__str__`          | 实例字符串表示,可读性 | print(类实例),如没实现，使用repr结果 |
| `__repr__`         | 实例字符串表示,准确性 | 类实例 回车 或者 print(repr(类实例)) |
| `__del__`          | 析构                  | del删除实例                          |
| `__dict__`         | 实例自定义属性        | `vars(实例.__dict__)`                |
| `__doc__`          | 类文档,子类不继承     | help(类或实例)                       |
| `__getattribute__` | 属性访问拦截器        | 访问实例属性时                       |
| `__bases__`        | 类的所有父类构成元素  | `类名.__bases__`                     |

#### `__getattribute__`

示例：每次调用对象的属性或方法的时候，都会先调用`__getattribute__` 方法进行拦截处理

该方法的第二个参数是调用属性以及方法的名称的字符串对象

```python
class Itcast(object):
    def __init__(self,subject1):
        self.subject1 = subject1
        self.subject2 = 'cpp'

    #属性访问时拦截器，打log
    def __getattribute__(self,obj):
        if obj == 'subject1':
            print('log subject1')
            return 'redirect python'
        else:   #测试时注释掉这2行，将找不到subject2
            return object.__getattribute__(self,obj)

    def show(self):
        print('this is Itcast')

s = Itcast("python")
print(s.subject1)
print(s.subject2)
# 结果
log subject1
redirect python
cpp
# 如果调用s.show()也会执行getattribute方法
```

注意：不要嵌套调用，在getattribute方法里面不要返回self.xxx

 ```python
    class Person(object):
        def __getattribute__(self,obj):
            print("---test---")
            if obj.startswith("a"):
                return "hahha"
            else:
                return self.test


        def test(self):
            print("heihei")


    t.Person()

    t.a #返回hahha

    t.b #会让程序死掉
        #原因是：当t.b执行时，会调用Person类中定义的__getattribute__方法，但是在这个方法的执行过程中
        #if条件不满足，所以 程序执行else里面的代码，即return self.test  问题就在这，因为return 需要把
        #self.test的值返回，那么首先要获取self.test的值，因为self此时就是t这个对象，所以self.test就是
        #t.test 此时要获取t这个对象的test属性，那么就会跳转到__getattribute__方法去执行，即此时产
        #生了递归调用，由于这个递归过程中 没有判断什么时候推出，所以这个程序会永无休止的运行下去，又因为
        #每次调用函数，就需要保存一些数据，那么随着调用的次数越来越多，最终内存吃光，所以程序 崩溃
        # 注意：以后不要在__getattribute__方法中调用self.xxxx
 ```



### 内建方法

Build-in Function,启动python解释器，输入`dir(__builtins__)`, 可以看到很多python解释器启动后默认加载的属性和函数，这些函数称之为内建函数， 这些函数因为在编程时使用较多，cpython解释器用c语言实现了这些函数，启动解释器 时默认加载。

这些函数数量众多，不宜记忆，开发时不是都用到的，待用到时再help(function), 查看如何使用，或结合百度查询即可，在这里介绍些常用的内建函数。

#### range

```python
    range(stop) -> list of integers
    range(start, stop[, step]) -> list of integers
```

- start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）;
- stop:到stop结束，但不包括stop.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5
- step:每次跳跃的间距，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)

python2中range返回列表，python3中range返回一个迭代值。如果想得到列表,可通过list函数

```python
a = range(5)
list(a)
```

创建列表的另外一种方法

```python
In [21]: testList = [x+2 for x in range(5)]
In [22]: testList
Out[22]: [2, 3, 4, 5, 6]
```

#### map函数

map函数会根据提供的函数对指定序列做映射

```python
    map(...)
        map(function, sequence[, sequence, ...]) -> list
```

- function:是一个函数
- sequence:是一个或多个序列,取决于function需要几个参数
- 返回值是一个list

参数序列中的每一个元素分别调用function函数，返回包含每次function函数返回值的list。

```python
#函数需要一个参数
map(lambda x: x*x, [1, 2, 3])
#结果为:[1, 4, 9]

#函数需要两个参数
map(lambda x, y: x+y, [1, 2, 3], [4, 5, 6])
#结果为:[5, 7, 9]


def f1( x, y ):  
    return (x,y)

l1 = [ 0, 1, 2, 3, 4, 5, 6 ]  
l2 = [ 'Sun', 'M', 'T', 'W', 'T', 'F', 'S' ]
l3 = map( f1, l1, l2 ) 
print(list(l3))
#结果为:[(0, 'Sun'), (1, 'M'), (2, 'T'), (3, 'W'), (4, 'T'), (5, 'F'), (6, 'S')]
```

#### filter函数

filter函数会对指定序列执行过滤操作

```
filter(...)
    filter(function or None, sequence) -> list, tuple, or string

    Return those items of sequence for which function(item) is true.  If
    function is None, return the items that are true.  If sequence is a tuple
    or string, return the same type, else return a list.
```

- function:接受一个参数，返回布尔值True或False
- sequence:序列可以是str，tuple，list

filter函数会对序列参数sequence中的每个元素调用function函数，最后返回的结果包含调用结果为True的元素。

返回值的类型和参数sequence的类型相同

```python
filter(lambda x: x%2, [1, 2, 3, 4]) # 为0则是False 所有大于1的值是True
[1, 3]

filter(None, "she")
'she'
```

#### reduce函数

reduce函数，reduce函数会对参数序列中元素进行累积

```
reduce(...)
    reduce(function, sequence[, initial]) -> value

    Apply a function of two arguments cumulatively to the items of a sequence,
    from left to right, so as to reduce the sequence to a single value.
    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
    of the sequence in the calculation, and serves as a default when the
    sequence is empty.
```

- function:该函数有两个参数
- sequence:序列可以是str，tuple，list
- initial:固定初始值

reduce依次从sequence中取一个元素，和上一次调用function的结果做参数再次调用function。 第一次调用function时，如果提供initial参数，会以sequence中的第一个元素和initial 作为参数调用function，否则会以序列sequence中的前两个元素做参数调用function。 注意function函数不能为None。

```python
reduce(lambda x, y: x+y, [1,2,3,4]) #等价于 reduce(lambda x,y:x+y,[1,2,3,4],0)
10

reduce(lambda x, y: x+y, [1,2,3,4], 5)
15

reduce(lambda x, y: x+y, ['aa', 'bb', 'cc'], 'dd')
'ddaabbcc'
```

> 在Python3里,reduce函数已经被从全局名字空间里移除了, 它现在被放置在fucntools模块里用的话要先引入： `from functools import reduce`

#### sorted函数

```python
sorted(...)
    sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
```

示例：

```python
In [13]: sorted([1,4,5,2,6,2,0])
Out[13]: [0, 1, 2, 2, 4, 5, 6]
In [14]: sorted([1,4,5,2,6,2,0],reverse=1)
Out[14]: [6, 5, 4, 2, 2, 1, 0]
In [15]: sorted(['a','e','b','w'])
Out[15]: ['a', 'b', 'e', 'w']
In [16]: sorted(['a','e','b','w'],reverse=1)
Out[16]: ['w', 'e', 'b', 'a']
```

### 集合set

使用较少，类似于数据库中的一些操作 求集合，交集，差集等

集合与之前列表、元组类似，可以存储多个数据，但是这些数据是不重复的

集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric_difference(对称差集)等数学运算.

```python
In [18]: a = "abcdef"
In [19]: a = set(a)
In [20]: a
Out[20]: {'a', 'b', 'c', 'd', 'e', 'f'}
In [21]: b = "efgh"
In [22]: b = set(b)
In [23]: b
Out[23]: {'e', 'f', 'g', 'h'}

In [24]: a&b # 交集
Out[24]: {'e', 'f'}

In [25]: a|b # 并集
Out[25]: {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}

In [26]: b-a # 差集
Out[26]: {'g', 'h'}

In [27]: b^a # 对称差集 (在a或b中，但不会同时出现在二者中)
Out[27]: {'a', 'b', 'c', 'd', 'g', 'h'}
```

### functools

python3.5中 

```
import functools
dir(functools)
```

在2.7中是默认加入的

运行结果：

```python
['MappingProxyType',
 'RLock',
 'WRAPPER_ASSIGNMENTS',
 'WRAPPER_UPDATES',
 'WeakKeyDictionary',
 '_CacheInfo',
 '_HashedSeq',
 '__all__',
 '__builtins__',
 '__cached__',
 '__doc__',
 '__file__',
 '__loader__',
 '__name__',
 '__package__',
 '__spec__',
 '_c3_merge',
 '_c3_mro',
 '_compose_mro',
 '_convert',
 '_find_impl',
 '_ge_from_gt',
 '_ge_from_le',
 '_ge_from_lt',
 '_gt_from_ge',
 '_gt_from_le',
 '_gt_from_lt',
 '_le_from_ge',
 '_le_from_gt',
 '_le_from_lt',
 '_lru_cache_wrapper',
 '_lt_from_ge',
 '_lt_from_gt',
 '_lt_from_le',
 '_make_key',
 'cmp_to_key',
 'get_cache_token',
 'lru_cache',
 'namedtuple',
 'partial',
 'partialmethod',
 'reduce',
 'singledispatch',
 'total_ordering',
 'update_wrapper',
 'wraps']
```

python3中增加了更多工具函数，做业务开发时大多情况下用不到，此处介绍使用频率较高的2个函数。

#### partial函数(偏函数)

把一个函数的某些参数设置默认值，返回一个新的函数，调用这个新函数会更简单。

```python
import functools

def showarg(*args, **kw):
    print(args)
    print(kw)

p1=functools.partial(showarg, 1,2,3)
p1()
p1(4,5,6)
p1(a='python', b='itcast')

p2=functools.partial(showarg, a=3,b='linux')
p2()
p2(1,2)
p2(a='python', b='itcast')
```

#### wraps函数

使用装饰器时，有一些细节需要被注意。例如，被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变）。

添加后由于函数名和函数的doc发生了改变，对测试结果有一些影响，例如:

```python
def note(func):
    "note function"
    def wrapper():
        "wrapper function"
        print('note something')
        return func()
    return wrapper

@note
def test():
    "test function"
    print('I am test')

test()
print(test.__doc__)
```

运行结果

```
note something
I am test
wrapper function
```

所以，Python的functools包中提供了一个叫wraps的装饰器来消除这样的副作用。例如：

```
import functools
def note(func):
    "note function"
    @functools.wraps(func)
    def wrapper():
        "wrapper function"
        print('note something')
        return func()
    return wrapper

@note
def test():
    "test function"
    print('I am test')

test()
print(test.__doc__)
```

运行结果

```
note something
I am test
test function
```

### 常见模块

Python有一套很有用的标准库(standard library)。标准库会随着Python解释器，一起安装在你的电脑中的。 它是Python的一个组成部分。这些标准库是Python为你准备好的利器，可以让编程事半功倍。 

#### 常用标准库

| 标准库          | 说明                   |
| --------------- | ---------------------- |
| builtins        | 内建函数默认加载       |
| os              | 操作系统接口           |
| sys             | Python自身的运行环境   |
| functools       | 常用的工具             |
| json            | 编码和解码 JSON 对象   |
| logging         | 记录日志，调试         |
| multiprocessing | 多进程                 |
| threading       | 多线程                 |
| copy            | 拷贝                   |
| time            | 时间                   |
| datetime        | 日期和时间             |
| calendar        | 日历                   |
| hashlib         | 加密算法               |
| random          | 生成随机数             |
| re              | 字符串正则匹配         |
| socket          | 标准的 BSD Sockets API |
| shutil          | 文件和目录管理         |
| glob            | 基于文件通配符搜索     |

##### hashlib

```python
import hashlib
m = hashlib.md5()   #创建hash对象，md5:(message-Digest Algorithm 5)消息摘要算法,得出一个128位的密文
print m             #<md5 HASH object>
m.update('itcast')  #更新哈希对象以字符串参数
print m.hexdigest() #返回十六进制数字字符串
```

示例：

```python
import hashlib
import datetime
KEY_VALUE = 'Itcast'
now = datetime.datetime.now()
m = hashlib.md5()
str = '%s%s' % (KEY_VALUE,now.strftime("%Y%m%d"))
m.update(str.encode('utf-8'))
value = m.hexdigest()
print(value)
```

#### 常用扩展库

| 扩展库               | 说明                                            |
| -------------------- | ----------------------------------------------- |
| requests             | 使用的是 urllib3，继承了urllib2的所有特性，爬虫 |
| urllib               | 基于http的高层库，爬虫                          |
| scrapy               | 爬虫                                            |
| beautifulsoup4       | HTML/XML的解析器                                |
| celery               | 分布式任务调度模块                              |
| redis                | 缓存                                            |
| Pillow(PIL)          | 图像处理                                        |
| xlsxwriter           | 仅写excle功能,支持xlsx                          |
| xlwt                 | 仅写excle功能,支持xls ,2013或更早版office       |
| xlrd                 | 仅读excle功能                                   |
| elasticsearch        | 全文搜索引擎                                    |
| pymysql              | 数据库连接库                                    |
| mongoengine/pymongo  | mongodbpython接口                               |
| matplotlib           | 画图                                            |
| numpy/scipy          | 科学计算，数据挖掘                              |
| django/tornado/flask | web框架                                         |
| xmltodict            | xml 转 dict                                     |
| SimpleHTTPServer     | 简单地HTTP Server,不使用Web框架                 |
| gevent               | 基于协程的Python网络库                          |
| fabric               | 系统管理                                        |
| pandas               | 数据处理库                                      |
| scikit-learn         | 机器学习库                                      |

##### 本地服务器

python2中

```
    python -m SimpleHTTPServer PORT
```

python3中

```
    python -m http.server PORT
```

##### 读写excel文件

1.安装个easy_install工具

```
    sudo apt-get install python-setuptools
```

2.安装模块

```
    sudo easy_install xlrd
    sudo easy_install xlwt
```

### 调试

pdb是基于命令行的调试工具，非常类似gnu的gdb（调试c/c++）



## Linux 系统编程

以下操作是Linux环境下生效

#### 进程

##### 进程的创建 -fork

示例：2个进程同时执行，使用fork创建一个进程

父子进程的执行顺序由操作系统调度决定

```python
import os
import time

ret = os.fork()
# --------- 从此处开始多个进程执行相同的代码
# 子进程的标号每次编译后执行的值不一样
# ret 返回的值是子进程的pid 父进程获取到子进程的ret > 0
# 而对于子进程而言 ret的值是 0 
if (ret == 0):
    print(ret)
	while True:
		print("-----1----")
		time.sleep(1)
else:
    print(ret)
	while True:
		print("-----2----")
		time.sleep(1)
```

- 程序执行到os.fork()时，操作系统会创建一个新的进程（子进程），然后复制父进程的所有信息到子进程中

- 然后父进程和子进程都会从fork()函数中得到一个返回值，在子进程中这个值一定是0，而父进程中是子进程的 id号

- 在Unix/Linux操作系统中，提供了一个fork()系统函数，它非常特殊。

  普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。

  子进程永远返回0，而父进程返回子进程的ID。

  这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID



##### 获取进程pid - getpid&getppid

用于获取当前进程的id和父进程的id

示例：

```python
import os

ret = os.fork()
if ret < 0:
	print("fork调用失败")
elif ret == 0:
	print("当前是子进程：%s,父进程：%s"%(os.getpid(),os.getppid()))
elif ret > 0:
	print("当前是父进程：%s"%(os.getpid()))

# 结果：
当前是父进程：88238
当前是子进程：88239,父进程：88238
```

##### 进程中的全局变量不共享

全局变量在fork进程的时候会复制一份，多进程中，每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响

```python
import os
import time

g_num = 100
ret = os.fork()

if ret < 0:
	print("fork调用失败")
elif ret == 0:
	print("--process1--")
	g_num += 1
	print("--process1--g_num--%d"%g_num)
elif ret > 0:
	print("--process2--")	
	time.sleep(3)
	print("--process2--g_num--%d"%g_num)
	
# 结果
--process2--
--process1--
--process1--g_num--101
--process2--g_num--100
```



#### multiprocessing跨平台创建进程（推荐）

由于在linux下支持fork函数，而windows不支持，通过multiprocessing模块提供了Process类提供统一的接口，在不同的环境下调用不同的函数

与fork方式的不同点：

​	1.跨平台支持

​	2.主进程等待子进程结束后才结束

```python
#coding = utf-8
from multiprocessing import Process
import os

# 子进程需要执行的代码
def sub_process_handle(name,age,**kwargs):
    i = 0
    while i <= 3:
        print("子进程%s执行中 pid=%d 次数%d"%(name,os.getpid(),i))
        print(age)
        print(kwargs)
        i += 1

if(__name__ == '__main__'):
    print("父进程执行中 pid=%d"%os.getpid())
    # 声明子进程 如果handle只有一个name参数，那么args={‘test’,}
    p = Process(target=sub_process_handle,args=('test',18),kwargs={'m':11})
    print("开始执行子进程")
    p.start()
    # 此处表示子进程结束后方可继续执行主进程
    p.join()
    print('子进程结束')
    
# 结果：
父进程执行中 pid=89166
开始执行子进程
子进程test执行中 pid=89167 次数0
18
{'m': 11}
子进程test执行中 pid=89167 次数1
18
{'m': 11}
子进程test执行中 pid=89167 次数2
18
{'m': 11}
子进程test执行中 pid=89167 次数3
18
{'m': 11}
子进程结束
```

- 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。
- join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步

##### 语法结构

Process([group [, target [, name [, args [, kwargs]]]]])

- target：表示这个进程实例所调用对象
- args：表示调用对象的位置参数元组
- kwargs：表示调用对象的关键字参数字典
- name：为当前进程实例的别名
- group：大多数情况下用不到

Process类常用方法：

- is_alive()：判断进程实例是否还在执行
- join([timeout])：是否等待进程实例执行结束，或等待多少秒
- start()：启动进程实例（创建子进程）
- run()：如果没有给定target参数，对这个对象调用start()方法时，就将执行对象中的run()方法
- terminate()：不管任务是否完成，立即终止

Process类常用属性：

- name：当前进程实例别名，默认为Process-N，N为从1开始递增的整数
- pid：当前进程实例的PID值

```python
#coding=utf-8
from multiprocessing import Process
import time
import os

#两个子进程将会调用的两个方法
def  worker_1(interval):
    print("worker_1,父进程(%s),当前进程(%s)"%(os.getppid(),os.getpid()))
    t_start = time.time()
    time.sleep(interval) #程序将会被挂起interval秒
    t_end = time.time()
    print("worker_1,执行时间为'%0.2f'秒"%(t_end - t_start))

def  worker_2(interval):
    print("worker_2,父进程(%s),当前进程(%s)"%(os.getppid(),os.getpid()))
    t_start = time.time()
    time.sleep(interval)
    t_end = time.time()
    print("worker_2,执行时间为'%0.2f'秒"%(t_end - t_start))

#输出当前程序的ID
print("进程ID：%s"%os.getpid())

#创建两个进程对象，target指向这个进程对象要执行的对象名称，
#args后面的元组中，是要传递给worker_1方法的参数，
#因为worker_1方法就一个interval参数，这里传递一个整数2给它，
#如果不指定name参数，默认的进程对象名称为Process-N，N为一个递增的整数
p1=Process(target=worker_1,args=(2,))
p2=Process(target=worker_2,name="dongGe",args=(1,))

#使用"进程对象名称.start()"来创建并执行一个子进程，
#这两个进程对象在start后，就会分别去执行worker_1和worker_2方法中的内容
p1.start()
p2.start()

#同时父进程仍然往下执行，如果p2进程还在执行，将会返回True
print("p2.is_alive=%s"%p2.is_alive())

#输出p1和p2进程的别名和pid
print("p1.name=%s"%p1.name)
print("p1.pid=%s"%p1.pid)
print("p2.name=%s"%p2.name)
print("p2.pid=%s"%p2.pid)

#join括号中不携带参数，表示父进程在这个位置要等待p1进程执行完成后，
#再继续执行下面的语句，一般用于进程间的数据同步，如果不写这一句，
#下面的is_alive判断将会是True，在shell（cmd）里面调用这个程序时
#可以完整的看到这个过程，大家可以尝试着将下面的这条语句改成p1.join(1)，
#因为p2需要2秒以上才可能执行完成，父进程等待1秒很可能不能让p1完全执行完成，
#所以下面的print会输出True，即p1仍然在执行
p1.join()
print("p1.is_alive=%s"%p1.is_alive())

# 结果
进程ID：19866
p2.is_alive=True
p1.name=Process-1
p1.pid=19867
p2.name=dongGe
p2.pid=19868
worker_1,父进程(19866),当前进程(19867)
worker_2,父进程(19866),当前进程(19868)
worker_2,执行时间为'1.00'秒
worker_1,执行时间为'2.00'秒
p1.is_alive=False
```



##### 自定义Process类（继承Process类）

类似于java中的线程子类，或者线程接口，需要重写run方法

自定义进程在start方法执行时，会自动调用run方法，如果传参在start方法中，则会忽略run方法

```python
#coding = utf-8
from multiprocessing import Process
import time
import os

class MyProcess(Process):
    def __init__(self,interval):
        Process.__init__(self)
        self.interval = interval

    def run(self):
        print("子进程%s 开始执行,父进程为%d"%(os.getpid(),os.getppid()))
        t_start = time.time()
        time.sleep(self.interval)
        t_end = time.time()
        print("%s 执行结束 耗时%0.2fs"%(os.getpid(),t_end - t_start))


if __name__ == "__main__":
    t_start = time.time()
    print("当前程序进程(%s)"%os.getpid())
    p1 = MyProcess(3)
    p1.start()
    p1.join()
    t_end = time.time()
    print("%s 执行结束 耗时%0.2fs"%(os.getpid(),t_end - t_start))
    
# 结果:
当前程序进程(89352)
子进程89353 开始执行,父进程为89352
89353 执行结束 耗时3.00s
89352 执行结束 耗时3.02s
```



##### 进程池Pool

当要创建大量的进程的时候，推荐使用进程池，解决节省创建进程和销毁进的代价

初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行 

```python
#coding = utf-8
from multiprocessing import Pool
import os
import time,random

def worker(msg):
    t_start = time.time()
    print("%s 开始执行，进程号为%d"%(msg,os.getpid()))
    # random.random() 0~1的随机数
    time.sleep(random.random()*10)
    t_end = time.time()
    print(msg,"执行完毕 耗时%0.2f"%(t_end - t_start))

# 创建线程池
po = Pool(3)

for i in range(0,10):
    # Pool.apply_async(要调用的目标，(传递给目标的元祖,))
    po.apply_async(worker,(i,))

print("---start---")
po.close()
# join必须要在close之后
po.join()
print("---end---")

# 结果
---start---
0 开始执行，进程号为91058
2 开始执行，进程号为91059
1 开始执行，进程号为91057
1 执行完毕 耗时0.46
3 开始执行，进程号为91057
2 执行完毕 耗时0.60
4 开始执行，进程号为91059
4 执行完毕 耗时0.13
5 开始执行，进程号为91059
5 执行完毕 耗时0.25
6 开始执行，进程号为91059
0 执行完毕 耗时1.27
7 开始执行，进程号为91058
7 执行完毕 耗时0.30
8 开始执行，进程号为91058
3 执行完毕 耗时1.72
9 开始执行，进程号为91057
9 执行完毕 耗时0.02
8 执行完毕 耗时1.10
6 执行完毕 耗时1.74
---end---
```

multiprocessing.Pool常用函数解析：

- apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；
- apply(func[, args[, kwds]])：使用阻塞方式调用func
- close()：关闭Pool，使其不再接受新的任务；
- terminate()：不管任务是否完成，立即终止；
- join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用

apply阻塞式调用进程池

```python
#coding = utf-8
from multiprocessing import Pool
import os,time,random

def worker(msg):
    t_start = time.time()
    print("%s 开始执行，进程号为%d"%(msg,os.getpid()))
    # random.random() 0~1的随机数
    time.sleep(random.random()*2)
    t_end = time.time()
    print(msg,"执行完毕 耗时%0.2f"%(t_end - t_start))

# 创建线程池
po = Pool(3)

for i in range(0,10):
    # Pool.apply_async(要调用的目标，(传递给目标的元祖,))
    po.apply(worker,(i,))

print("---start---")
po.close()
# join必须要在close之后
po.join()
print("---end---")

# 结果：从结果中可以看出，---start---都要在进程池中的进程结束后才执行
0 开始执行，进程号为90919
0 执行完毕 耗时0.83
1 开始执行，进程号为90920
1 执行完毕 耗时0.99
2 开始执行，进程号为90918
2 执行完毕 耗时1.26
3 开始执行，进程号为90919
3 执行完毕 耗时0.78
4 开始执行，进程号为90920
4 执行完毕 耗时1.15
5 开始执行，进程号为90918
5 执行完毕 耗时0.63
6 开始执行，进程号为90919
6 执行完毕 耗时1.89
7 开始执行，进程号为90920
7 执行完毕 耗时1.95
8 开始执行，进程号为90918
8 执行完毕 耗时0.26
9 开始执行，进程号为90919
9 执行完毕 耗时0.46
---start---
---end---
```



##### 进程通信-Queue

进程间的消息队列，先进先出

```python
#coding=utf-8

from multiprocessing import Queue

q = Queue(3) # 初始化一个queue 大小是３ 如果没有指定大小，那么说明接受的数量没有限制，最大内存可以接受的范围
q.put("msg1")
q.put("msg2")
print(q.full()) # 判断队列是否已经满了
q.put("msg3")
print(q.full())

# 由于队列已经满了，因此在put的时候会报异常 

try:
    q.put("msg4",True,2) # True表示阻塞，2表示等待2s，如果没有阻塞超过2s则报异常
except:
    print("消息队列已满 消息数量%s"%q.qsize())

try:
    q.put_nowait("msg5") # 非等待直接抛出异常
except:
   print("消息队列已满 消息数量%s"%q.qsize())

# 推荐的书写方法
if not q.full():
    q.put_nowait("msg6")

# 读取消息的时候，判断消息是否为空
if not q.empty():
    for i in range(q.qsize()):
        print(q.get_nowait())

```

- Queue.qsize()：返回当前队列包含的消息数量；
- Queue.empty()：如果队列为空，返回True，反之False ；
- Queue.full()：如果队列满了，返回True,反之False；
- Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；

1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出"Queue.Empty"异常；

2）如果block值为False，消息列队如果为空，则会立刻抛出"Queue.Empty"异常；

- Queue.get_nowait()：相当Queue.get(False)；
- Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；

1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出"Queue.Full"异常；

2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出"Queue.Full"异常；

- Queue.put_nowait(item)：相当Queue.put(item, False)；

###### Queue实例

在父进程中创建2个进程，一个在Queue中写入数据，一个从Queue中取得数据

```python
# coding=utf-8
from multiprocessing import Process,Queue
import os,time,random

# 注意：在windows情况下执行不成功，在ubuntu执行成功

# 写数据进程
def write(q):
    for v in ['a','b','c']:
        print('put %s to queue...'%v)
        q.put(v)
        time.sleep(1)

# 读数据进程
def read(q):
    while True:
        if not q.empty():
            v = q.get(True)
            print('get %s from queue'%v)
            time.sleep(random.random())
        else:
            # 读取完queue中的进程就结束
            break

if __name__ == '__main__':
    q = Queue()
    pw = Process(target=write,args=(q,))
    pr = Process(target=read,args=(q,))
    # 启动进程
    pw.start()
    # 等待pw进程写结束
    pw.join()
    # 启动读进程
    pr.start()
    pr.join()
    print('---end---')
```

###### 进程池中的Queue

要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：RuntimeError: Queue objects should only be shared between processes through inheritance.

```python
# coding=utf-8
from multiprocessing import Manager,Pool
import os,time,random

def reader(q):
    print('reader start pid%s ppid%s '%(os.getpid(),os.getppid()))
    for i in range(q.qsize()):
        print('get from queue%s'%q.get(True))

def writer(q):
    print('writer start pid%s ppid%s '%(os.getpid(),os.getppid()))
    for i in 'helloword':
        q.put(i)

if __name__=='__main__':
    print('%s start'%os.getpid())
    q = Manager().Queue() # 在进程池中如果要使用队列，那么需要使用Manager对象进行生成
    pool = Pool()
    # 使用阻塞的机制创建进程
    pool.apply(writer,(q,))
    pool.apply(reader,(q,))
    pool.close()
    pool.join()
    print('---end---pid:%s'%os.getpid())

```



