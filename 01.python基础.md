# 01.python基础学习

### 简介

胶水语言，关键模块可以使用c编写，然后使用python调用

输入python和python3 进入python的命令交互模式

使用ipython和ipython3进入在python的命令交互模式中可以输入linux命令以及补全功能

原则上使用ipython3，即使用python3版本进行学习

书籍：

​	入门:python核心编程

​	提高:python cookbook

​	![1534947729786](resource\1534947729786.png)

### HelloWorld

```python
print("hello World");
```

- 运行：python3 xxx.py



### 注释

```py
# 单行注释
'''
多行注释
'''
```



### 中文支持

在python3中支持，但是在python2中直接输入中文会有报错，需要在文件头部添加 

```python
#coding=utf-8
print("你好");
```

python推荐写法

```py
#-*- coding:utf-8 -*-
```



### 变量

python中的变量的类型是由赋值的类型定义的

```python
num1 = 100;
print(type(num1)); #打印num1的类型 <type 'int'>
```

#### 类型

![1534948296592](resource\1534948296592.png)

#### 判断变量的类型

​	type(n)

#### 变量值互换

```python
# 第一种
tm = a
a = b
b = tm
# 第二种
a = a+b
b = a-b
a = a-b
# 第三种 python 独有
a,b = b,a
```



### 标识符规则

python中变量名称是区别大小写的

标示符由字母、下划线和数字组成，且数字不能开头 

变量名不能是已有关键字



### 关键字

```python
      and     as      assert     break     class      continue    def     del
      elif    else    except     exec      finally    for         from    global
      if      in      import     is        lambda     not         or      pass
      print   raise   return     try       while      with        yield
```

查看关键字命令

```python
import keyword
keyword.kwlist
```



### 格式化输出

print有默认换行的功能，如果要取消换行则

print("helloworld",end="")

```python
age = 10
print("岁数%d"%age)
name = "zhangsan"
print("姓名：%s 年龄：%d"%(name,age))
print("姓名：%s \n 年龄：%d"%(name,age)) # \n 表示换行
print("输入"+11) # 异常，和java不同，整型与字符串不能通过+号转换
print(11+22) # 33 
```

常用格式符号

| 格式符号 | 转换                         |
| :------: | :--------------------------- |
|    %c    | 字符                         |
|    %s    | 通过str() 字符串转换来格式化 |
|    %i    | 有符号十进制整数             |
|    %d    | 有符号十进制整数             |
|    %u    | 无符号十进制整数             |
|    %o    | 八进制整数                   |
|    %x    | 十六进制整数（小写字母）     |
|    %X    | 十六进制整数（大写字母）     |
|    %e    | 索引符号（小写'e'）          |
|    %E    | 索引符号（大写“E”）          |
|    %f    | 浮点实数                     |
|    %g    | ％f和％e 的简写              |
|    %G    | ％f和％E的简写               |

### 输入

```python
a = raw_input("请输入：") # 会在此处阻塞，直到有输入 无论输入何值返回都是string类型 python2
print(a)
a = input("请输入：") # python3 和 python2 都支持，区别在于 python2中 可以输入表达式，得到的是结果 但是python3的功能同raw_input 为了功能更加单一化
```



### 运算符

python支持以下几种运算符

- 算术运算符

下面以a=10 ,b=20为例进行计算

| 运算符 | 描述   | 实例                                                         |
| ------ | ------ | ------------------------------------------------------------ |
| +      | 加     | 两个对象相加 a + b 输出结果 30                               |
| -      | 减     | 得到负数或是一个数减去另一个数 a - b 输出结果 -10            |
| *      | 乘     | 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 |
| /      | 除     | x除以y b / a 输出结果 2                                      |
| //     | 取整除 | 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0     |
| %      | 取余   | 返回除法的余数 b % a 输出结果 0                              |
| **     | 幂     | 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 |

```python
>>> 9/2.0
4.5
>>> 9//2.0
4.0
```

- 赋值运算符

| 运算符 | 描述       | 实例                                                 |
| ------ | ---------- | ---------------------------------------------------- |
| =      | 赋值运算符 | 把=号右边的结果给左边的变量 num=1+2*3 结果num的值为7 |

```python
>>> a, b = 1, 2
>>> a
1
>>> b
2
```

- 复合赋值运算符

| 运算符 | 描述             | 实例                      |
| ------ | ---------------- | ------------------------- |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a   |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a   |
| *=     | 乘法赋值运算符   | c *= a 等效于 c = c * a   |
| /=     | 除法赋值运算符   | c /= a 等效于 c = c / a   |
| %=     | 取模赋值运算符   | c %= a 等效于 c = c % a   |
| **=    | 幂赋值运算符     | c **= a 等效于 c = c ** a |
| //=    | 取整除赋值运算符 | c //= a 等效于 c = c // a |

### 数据类型转换

注意eval的使用，如可以将string类型的数组转成数组对象

| 函数                   | 说明                                                    |
| ---------------------- | ------------------------------------------------------- |
| int(x [,base ])        | 将x转换为一个整数                                       |
| long(x [,base ])       | 将x转换为一个长整数                                     |
| float(x )              | 将x转换到一个浮点数                                     |
| complex(real [,imag ]) | 创建一个复数                                            |
| str(x )                | 将对象 x 转换为字符串                                   |
| repr(x )               | 将对象 x 转换为表达式字符串                             |
| ==eval(str )==         | **用来计算在字符串中的有效Python表达式,并返回一个对象** |
| tuple(s )              | 将序列 s 转换为一个元组                                 |
| list(s )               | 将序列 s 转换为一个列表                                 |
| chr(x )                | 将一个整数转换为一个字符                                |
| unichr(x )             | 将一个整数转换为Unicode字符                             |
| ord(x )                | 将一个字符转换为它的整数值                              |
| hex(x )                | 将一个整数转换为一个十六进制字符串                      |
| oct(x )                | 将一个整数转换为一个八进制字符串                        |

```python
a = '100' # 此时a的类型是一个字符串，里面存放了100这3个字符
b = int(a) # 此时b的类型是整型，里面存放的是数字100
print("a=%d"%b)
```



### if语句

```python
if 条件1：
	执行1 # 注意缩进
else：
	执行2
    
if xxx:
    pass
elif xxx:
    pass
```



### 运算符

| 运算符  | 描述                                                         | 示例                          |
| ------- | ------------------------------------------------------------ | ----------------------------- |
| ==      | 检查两个操作数的值是否相等，如果是则条件变为真。             | 如a=3,b=3则（a == b) 为 true. |
| != 或<> | 检查两个操作数的值是否相等，如果值不相等，则条件变为真。     | 如a=1,b=3则(a != b) 为 true.  |
| >       | 检查左操作数的值是否大于右操作数的值，如果是，则条件成立。   | 如a=7,b=3则(a > b) 为 true.   |
| <       | 检查左操作数的值是否小于右操作数的值，如果是，则条件成立。   | 如a=7,b=3则(a < b) 为 false.  |
| >=      | 检查左操作数的值是否大于或等于右操作数的值，如果是，则条件成立。 | 如a=3,b=3则(a >= b) 为 true.  |
| <=      | 检查左操作数的值是否小于或等于右操作数的值，如果是，则条件成立。 | 如a=3,b=3则(a <= b) 为 true.  |

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| ------ | ---------- | ------------------------------------------------------------ | ----------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

### 循环

#### while循环

```python
while 条件:
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足时，做的事情3
    ...(省略)...
```

#### for循环

```python
for 临时变量 in 列表或者字符串等:
    循环满足条件时执行的代码
else:
    循环不满足条件时执行的代码
```

示例

```python
>>> name = "zhangsan"
>>> for n in name:
...     print(n)
```

break：跳出当前循环

continue：用来结束本次循环，紧接着执行下一次的循环 



### 字符串 str

#### 下标

```python
str = "name"
print(str[1]) # 获取下标1的字母，下标从0开始
```

#### 切片(类似subString)

```python
#[开始：结束：步长]
str = "name"
print(str[1:3]) # 取得[1，3）范围内的字符子串
print(str[1:]) # 取得从1开始到结束的子字符串
print(str[1:-1]) # 取得[1,len-1)字符串之间的子字符串
# 注意，第三个是步长
 >>> a = "abcdef"
 >>> a[:3]
 'abc'
 >>> a[::2]
 'ace'
 >>> a[5:1:2] 
 ''
 >>> a[1:5:2]
 'bd'
 >>> a[::-2]
 'fdb' 
 >>> a[5:1:-2]
 'fd'
```

#### len - 获取字符串长度

```python
str = "name"
print(len(str))
```

#### find - 查找字符串 str.find(strb,start,end)

rfind - 从右侧开始查找

```python
str = "i have a dream"
print(str.find("a")) # 查询得到a字符串第一个位置的index
print(str.find("d",0)) # 从0下标开始到最后结束
print(str,find("c",0,len(str))) # 查询str中特定的范围内的字符串的位置，如果不存在则返回-1
```

#### index - 查找子字符串的位置 str.index(strb,start,end)

rindex - 从右侧开始查找，index默认从左侧查找

```python
str = "i have a dream"
print(str.index("a")) # 功能同find 但是如果不存在则会抛出异常
```

#### count - 查找子字符串的在字符串中的个数 str.count(strb,start,end);

```python
str = "i have a dream"
print(str.count("a")) 
```

#### replace - 替换字符串中的指定子串为特定子串，并且有替换个数限制，返回一个新串

```python
str = "i have a dream"
print(str.replace("a","ss",2)) # 将a 替换为 ss ，替换个数为2个 注意返回的是一个新字符串
print(str.replace("a","ss")) # 表示替换全部的a子串为ss子串
```

#### split - 分割字符串

```python
str = "i have a dream"
print(str.split(" ",2)) # 表示以空格分割字符串，2表示空格的个数，最多分割2个子串
print(str.split(" ")) # 表示分割字符串，没有个数限制，有多少就分割多少
```

#### capitalize - 将字符串首字母大写

```python
str = "name"
print(str.capitalize())
```

#### title - 将字符串中的所有单词的首字母大写

```python
str.title()
```

#### startswith - 判断是否以某个子串开头

```python
str.startswith("ss"); # 返回boolean类型 True和False
```

#### endswith - 判断是否已某个子串结尾

```python
str.endswith("ss");
```

#### lower upper - 将字符串中的大写变小写 小写变大写

```python
str.lower() # 都是返回一个新串
str.upper()
```

#### ljust - 将原字符串左对齐，并填充指定个数的字符

```python
str.ljust(10,"*") # 左对齐，填充指定个数的* 如果str的长度小于指定的个数，那么不做处理
str.ljust(10) # 左对齐，不足的部分填充空格
```

#### rjust - 同上，不过是右对齐，左边补充指定个数字符

#### center -  同上，居中对齐，两侧补充指定个数字符

#### lstrip rstrip strip - 去除字符串左右空格，类似trim

```python
str.lstrip(); # 去除左侧空格
str.rstrip(); # 去除右侧空格
str.strip(); # 去除双侧空格
str.lstrip("*"); # 去除左侧*号，其他的同上
```

#### partition - 将字符串以某个子串进行分割

rpartition - 同上，不过是从右边开始判断

```python
str = "i have a dream "
print(str.partition("a")) # ('i h', 'a', 've a dream')
print(str.rpartition("a")) # ('i have a dre', 'a', 'm')
```

#### splitlines - 按照回车\n 进行拆分

```python
str = "i have a \n dream"
str.splitlines() # ['i have a ', ' dream']
str.split("\n") # 结果同上
```

#### isalpha - 判断所有字符都是字母

#### isdigit - 判断所有字符都是数字

#### isalnum - 判断所有字符都是数字或者字母

#### isspace - 判断所有字符只能是空格，空字符串都不行

```python
str.isalpha() # 返回True或者False str中有回车 空格 都返回false
```

#### join - 连接字符串，并返回

```python
>>> str = "sss"
>>> str.join("ttt") # 将字符串视为字符数组
'tssstssst'
>>> li = ["aa","bb","cc"]
>>> str = "_"
>>> str.join(li)
'aa_bb_cc'
```





### 列表

等价于数组，List，可以添加删除元素

```python
names = ["zhangsan","lisi","wangwu"]
# 不同于其他语言，元素可以多样混合
objs = [1,2,"zhangsan","lisi"]
```

#### 循环调用

```python
for o in objs:
    print(o)
   
length = len(objs)
i = 0
while i < length:
    print(objs[i])
    i += 1
```

#### append - 添加元素

```python
objs.append('ssss')
b = [4,5]
objs.append(b) 
# [1, 2, 'zhangsan', 'lisi', 'ssss', [4, 5]]
```

#### extend - 添加一个集合

```python
objs.append(["aa","bb"]) 
# [1, 2, 'zhangsan', 'lisi', 'ssss', [4, 5], 'aa', 'bb']
```

#### insert - 在指定位置插入元素

```python
objs.insert(3，"wangwu") # 在下标3的位置插入元素 新增元素的下标是3
```

#### in - 判断元素是否存在列表中

not in - 与in 相反

```python
if 'aa' in objs:
    print("aa in objs")
```

#### index count - 用法同str

#### del - 删除指定元素

```python
del objs[2]
```

#### pop - 删除最后一个元素，并返回删除的元素

```python
objs.pop()
```

#### remove -  删除指定值的元素

```python
objs.remove("aa")
```

#### sort - 排序 ： 默认从小到大，会修改原先的列表

reverse - 从大到小

```python
objs.sort()
objs.reverse()
objs.sort(reverse = True) # 同reverse() 方法 注意True是首字母大写
```

#### 嵌套

```python
schoolNames = [['北京大学','清华大学'],
               ['南开大学','天津大学','天津师范大学'],
               ['山东大学','中国海洋大学']]
```



### 元组

类似于列表，但是不同的是不能进行修改

```python
tuple=(1,2,3)
# 访问元素
tuple[1]
# count 和 index 用法同str
```



### 字典

类似于js的对象，java中的map，组织形式是json

```python
info = {'name':'班长', 'id':100, 'sex':'f', 'address':'地球亚洲中国北京'}
# 如果元素不存在则报错
print(info['name'])
print(info['address'])
#新增元素
info['age'] = 21
#删除元素
del info['age']
#清空字典
info.clear()
# len 字典元素的个数
len(info)
# keys 返回元素key的列表
info.keys()
# values 返回元素value的列表
info.values()
# items 返回元素的key-value的列表
info.items()
# has_key 返回是否有某个key存在 存在返回True 否则返回False
info.has_key("name") 
```

注意：不可变类型可以作为key，入string ，int，以及元组类型，本质上将key进行了hash操作，生成一个唯一的值

#### 遍历

```python
for key.value in info.items():
    print("key:%s value:%s"%(key,value))
```

#### enumerate

将数组转换，遍历时可以提供索引

```python
for index,o in enumerate(objs):
    print(index)
    print(o)
```



### 公共方法

#### 运算符

| 运算符 | Python 表达式      | 结果                         | 描述                                              | 支持的数据类型           |
| ------ | ------------------ | ---------------------------- | ------------------------------------------------- | ------------------------ |
| +      | [1, 2] + [3, 4]    | [1, 2, 3, 4]                 | 合并                                              | 字符串、列表、元组       |
| *      | 'Hi!' * 4          | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 复制                                              | 字符串、列表、元组       |
| in     | 3 in (1, 2, 3)     | True                         | 元素是否存在， in在对字典操作时，判断的是字典的键 | 字符串、列表、元组、字典 |
| not in | 4 not in (1, 2, 3) | True                         | 元素是否不存在                                    | 字符串、列表、元组、字典 |

#### 内置函数

| 方法              | 描述                 |
| ----------------- | -------------------- |
| cmp(item1, item2) | 比较两个值           |
| len(item)         | 计算容器中元素个数   |
| max(item)         | 返回容器中元素最大值 |
| min(item)         | 返回容器中元素最小值 |
| del(item)         | 删除变量             |

**注意：cmp在比较字典数据时，先比较键，再比较值。** 



### 引用

#### id() - 返回对象的引用的地址，用于判断是否是同一个对象

可变类型，值可以改变：

- 列表 list
- 字典 dict

不可变类型，值不可以改变：

- 数值类型 int, long, bool, float
- 字符串 str
- 元组 tuple

#### 注意点：+= 和 = x + y 的区别

```python
In [43]: a = [11]
In [44]: id(a)
Out[44]: 140495809064832
In [45]: a += a
In [46]: a
Out[46]: [11, 11]
In [47]: id(a)
Out[47]: 140495809064832
In [48]: a = a+a #----> a = [11]+[11] 先算右边的，然后使用临时变量赋值
In [49]: a
Out[49]: [11, 11, 11, 11]
In [50]: id(a)
Out[50]: 140495809140136  
# 注意操作：a += a 和 a = a+a 返回的不是同一个对象
```



### 函数

```python
# 定义一个函数，能够完成打印信息的功能
def printInfo():
    print '------------------------------------'
    print '         人生苦短，我用Python'
    print '------------------------------------'
#执行函数
printInfo()
# 定义一个有入参和返回值的函数
 def add2num(a, b):
        c = a+b
        return c
# 可以按照入参的顺序调用，也可自定义入参顺序
add2num(1,3)
add2num(b=3,a=1)
```

#### 缺省值

```python
# 可定义缺省参数函数：注意，缺省的参数必须定义在最后
def printinfo( name, age = 35 ):
   # 打印任何传入的字符串
   print "Name: ", name
   print "Age ", age

# 调用printinfo函数
printinfo(name="miki" )
printinfo( age=9,name="miki" )
```

嵌套

```python
def testB():
    print('---- testB start----')
    print('这里是testB函数执行的代码...(省略)...')
    print('---- testB end----')
def testA():
    print('---- testA start----')
    testB()
    print('---- testA end----')
testA()
```

#### 全局变量

- 在函数外边定义的变量叫做`全局变量`
- 全局变量能够在所有的函数中进行访问
- 如果在函数中修改全局变量，那么就需要使用`global`进行声明，否则出错
- 如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量
- 可变类型的全局变量不需要加global即可调用，因为是引用类型

#### 不定长参数

c为元组，d为字典

```python
In [11]: def fun(a,b,*c,**d):
   ....:     print "a=",a
   ....:     print "b=",b
   ....:     print "c=",c
   ....:     print "d="
   ....:     for key,value in d.items():
   ....:         print key,"=",value
   ....:         

In [12]: fun(1,2,3,4,5,m=6,k=5,j=7)
a= 1
b= 2
c= (3, 4, 5)
d=
k = 5
j = 7
m = 6
# 第二种调用方式
In [14]: args = (3,4,5)
In [15]: kwargs = {"m":1,"n":2}
In [16]: fun(1,2,*args,**kwargs) # 注意* 和** 的使用 进行解包操作
a= 1
b= 2
c= (3, 4, 5)
d=
m = 1
n = 2
#如果不添加* 那么
In [18]: fun(1,2,args,kwargs)
a= 1
b= 2
c= ((3, 4, 5), {'m': 1, 'n': 2})
d=
```

参数传递是引用传递，如果是基础类型则是值传递

#### 返回多个值

本质上是利用了元组

```python
def divid(a,b):
    shang = a//b
    yushu = a%b
    return shang, yushu
sh, yu = divid(5,4) # 注意sh, 后面有空格
```



#### 匿名函数

用lambda关键字创建匿名函数

```python
sum = lambda a,b:a+b
print(sum(1,2))
```

Lambda函数能接收任何数量的参数但只能返回一个表达式的值

匿名函数不能直接调用print，因为lambda需要一个表达式

应用场景：

- 函数作为参数传递

```python
>>> def fun(a, b, opt):
...     print "a =", a
...     print "b =", b
...     print "result =", opt(a, b)
...
>>> fun(1, 2, lambda x,y:x+y)
a = 1
b = 2
result = 3
```

- 作为函数的内置参数
```python
stus = [
    {"name":"zhangsan", "age":18}, 
    {"name":"lisi", "age":19}, 
    {"name":"wangwu", "age":17}
]
# 按name排序
stus.sort(key = lambda x:x['name'])
# 按age排序
stus.sort(key = lambda x:x['age'])
```

从外部输入一个匿名函数执行

```python
def test(a,b,func):
    f = eval(func) # 在python3中输入的始终是字符串，需要转换为可执行函数
    return f(a,b)
fn = input("input a lambda:")
re = test(11,22,fn)
print(re)
```



### 文件操作  

```python
# 可以打开一个已经存在的文件，如果不存在则创建一个新文件
# 打开后会覆盖该文件，无论是否有内容
# 文件名，访问模式
# 访问模式是写模式时：如果文件不存在则创建一个新文件
# 如果是读模式，如果文件不存在，则报错
f = open("test.txt",'w') 
# 写内容
f.write("i have a dream")
# 关闭文件
f.close() 

f = open("test.txt","r")
# 读取文件，如果有参数，表示读取的字节数，如果没有参数表示读取所有内容
# 返回3个字节的内容，如果再次执行继续返回3个字节的内容，如果读取完毕，返回''
content = f.read(3)
print(content)
print("-"*30)
content = f.read()
print(content)
f.close()
```



#### 访问模式
| 访问模式 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| r        | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |
| w        | 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| a        | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| rb       | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 |
| wb       | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| ab       | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |
| r+       | 打开一个文件用于读写。文件指针将会放在文件的开头。           |
| w+       | 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| a+       | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |
| rb+      | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 |
| wb+      | 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 |
| ab+      | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |

#### readlines

 就像read没有参数时一样，readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素

```python
#coding=utf-8

f = open('test.txt', 'r')

content = f.readlines()

print(type(content))

i=1
for temp in content:
    print("%d:%s"%(i, temp))
    i+=1

f.close()
```

#### readline

```python
#coding=utf-8

f = open('test.txt', 'r')

content = f.readline()
print("1:%s"%content)

content = f.readline()
print("2:%s"%content)


f.close()
```

#### 文件备份

```python
#coding=utf-8

oldFileName = input("请输入要拷贝的文件名字:")

oldFile = open(oldFileName,'r')

# 如果打开文件
if oldFile:

    # 提取文件的后缀
    fileFlagNum = oldFileName.rfind('.')
    if fileFlagNum > 0:
        fileFlag = oldFileName[fileFlagNum:]

    # 组织新的文件名字
    newFileName = oldFileName[:fileFlagNum] + '[复件]' + fileFlag

    # 创建新文件
    newFile = open(newFileName, 'w')
    # 防止大文件读取写入操作
    while True:
        content = oldFile.read(1024)
        if len(content) == 0 :
            break
        newFile.write(content)

    # 关闭文件
    oldFile.close()
    newFile.close()
```

#### 定位读写

##### 获取当前位置 tell()

```python
# 打开一个已经存在的文件
f = open("test.txt", "r")
str = f.read(3)
print "读取的数据是 : ", str

# 查找当前位置 单位是字节数
position = f.tell()
print "当前文件位置 : ", position

str = f.read(3)
print "读取的数据是 : ", str

# 查找当前位置
position = f.tell()
print "当前文件位置 : ", position

f.close()
```

##### 定位到某个位置 seek(offset,from)

offset:偏移量（python3 不支持负数 python2支持）
from:方向
​	0:表示文件开头
​	1:表示当前位置
​	2:表示文件末尾

```python
# 打开一个已经存在的文件
f = open("test.txt", "r")
str = f.read(30)
print "读取的数据是 : ", str

# 查找当前位置
position = f.tell()
print "当前文件位置 : ", position

# 重新设置位置
f.seek(5,0)

# 查找当前位置
position = f.tell()
print "当前文件位置 : ", position

f.close()
```

#### 文件的重命名 os.rename

```python
import os
os.rename("oldname.xx","newname.xx")
```

#### 文件的删除 os.remove

```python
import os
os.remove("filename.xx")
```

#### 创建文件夹 os.mkdir

```python
import os
os.mkdir("filedir")
```

#### 获取当前目录 os.getcwd

```python
import os
os.getcwd()
```

#### 改变默认路径 os.chdir  跳转路径

```python
import os
os.chdir("../") # change dir
```

#### 删除文件夹 os.rmdir

```python
import os
os.rmdir("filedir")
```

#### 获取目录列表 os.listdir

```python
import os
os.listdir("./") # 将当前路径下的文件以及文件夹打印出来
```

#### 批量修改文件夹名称示例

```python
#coding=utf-8
# 批量在文件名前加前缀
import os
funFlag = 1 # 1表示添加标志  2表示删除标志
folderName = input("请输入要重命名的文件夹：")
#folderName = './renameDir/'
# 获取指定路径的所有文件名字
dirList = os.listdir(folderName)
# 遍历输出所有文件名字
for name in dirList:
    print name
    if funFlag == 1:
        newName = '[东哥出品]-' + name
    else if funFlag == 2:
        num = len('[东哥出品]-')
        newName = name[num:]
        print newName
        os.rename(folderName+name, folderName+newName)
```



### 面向对象

#### 类

##### 初始化方法`__new__`

该方法在构造方法之前执行，用于对类进行处理，一般在单例模式中使用

```python
class A(object):
    def __init__(self):
        print("这是 init 方法")

    def __new__(cls):
        print("这是 new 方法")
        return object.__new__(cls)

A()
```

- `__new__`至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供

- `__new__`必须要有返回值，返回实例化出来的实例，这点在自己实现`__new__`时要特别注意，可以return父类`__new__`出来的实例，或者直接是object的`__new__`出来的实例

- `__init__`有一个参数self，就是这个`__new__`返回的实例，`__init__`在`__new__`的基础上可以完成一些其它初始化的动作，`__init__`不需要返回值

- 我们可以将类比作制造商，`__new__`方法就是前期的原材料购买环节，`__init__`方法就是在有原材料的基础上，加工，初始化商品环节


##### 构造方法 `__init__` 

使用 `__init__()`方法 初始化定义对象属性

```python
class 类名
	# 初始化函数，默认设定
	def __init__():
        ...
	方法列表
```

示例：经典类

```python
class Car:
	def __init__(self,_wheelNum,_color):
        self.wheelNum = _wheelNum
        self.color = _color
 	
    def __str__(self):
      	return "color:"+self.color+" wheelNum:"+int(self.wheelNum)
   
	def getInfo(self):
        print('轮子%s 颜色%s'%(self.wheelNum,self.color))
    
   	def move(self):
    	print("车开始移动....")
        
myCar = Car(4,'black')
print(myCar)
```

关于self：
- 某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可


##### 创建对象

```python
myCar = Car()
myCar.wheelNum = 9 #给对象添加属性
myCar.color = 'red'
myCar.getInfo() # 调用对象的方法
myCar.move()
```

##### 私有属性&方法

如果有一个对象，当需要对其进行修改属性时，有2种方法

- 对象名.属性名 = 数据 ---->直接修改
- 对象名.方法名() ---->间接修改

为了更好的保存属性安全，即不能随意修改，一般的处理方式为

- 将属性定义为私有属性
- 添加一个可以调用的方法，供调用
- Python中没有像C++中public和private这些关键字来区别公有属性和私有属性
- 它是以属性命名方式来区分，如果在属性名前面加了**2个下划线'__'**，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。
- 同理，方法声明也是如此

```python
class People(object):

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

    def setName(self, newName):
        if len(newName) >= 5:
            self.__name = newName
        else:
            print("error:名字长度需要大于或者等于5")

xiaoming = People("dongGe")
print(xiaoming.__name)
```

##### 析构方法 `__del__`

创建对象后，python解释器默认调用`__init__()`方法；

当删除一个对象时，python解释器也会默认调用一个方法，这个方法为`__del__()`方法

```python
import time
class Animal(object):

    # 初始化方法
    # 创建完对象后会自动被调用
    def __init__(self, name):
        print('__init__方法被调用')
        self.__name = name # __name是私有方法

    # 析构方法
    # 当对象被删除时，会自动被调用
    def __del__(self):
        print("__del__方法被调用")
        print("%s对象马上被干掉了..."%self.__name)

# 创建对象
dog = Animal("哈皮狗")

# 删除对象
del dog

cat = Animal("波斯猫")
cat2 = cat
cat3 = cat

print("---马上 删除cat对象")
del cat
print("---马上 删除cat2对象")
del cat2
print("---马上 删除cat3对象")
del cat3

print("程序2秒钟后结束")
time.sleep(2)
```

- 当有1个变量保存了对象的引用时，此对象的引用计数就会加1
- 当使用del删除变量指向的对象时，如果对象的引用计数不会1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除

#### 继承

##### 单继承

```python
class Animal(object):
    def __init__(self,name,age=22):
        self.name = name
        self.age = age

    def eat(self):
        print("%s---eat"%self.name)

class Cat(Animal):
    def setName(self,name):
        self.name = name
    def run(self):
        print("%s---run"%self.name)

an = Animal("dongwu",44)
an.eat()

myCat = Cat("TOM",33)
myCat.eat()
myCat.run()
```

虽然子类没有声明init构造方法，但是父类实现了，子类自动继承了该构造方法

- 子类在继承的时候，在定义类时，小括号()中为父类的名字
- 父类的属性、方法，会被继承给子类

注意，父类的私有属性和方法子类不能使用

- 私有的属性，不能通过对象直接访问，但是可以通过方法访问
- 私有的方法，不能通过对象直接访问
- 私有的属性、方法，不会被子类继承，也不能被访问
- 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用

##### 多继承

```python
# 定义一个父类
class A:
    def printA(self):
        print('----A----')

# 定义一个父类
class B:
    def printB(self):
        print('----B----')

# 定义一个子类，继承自A、B
class C(A,B):
    def printC(self):
        print('----C----')

obj_C = C()
obj_C.printA()
obj_C.printB()
```

##### 调用父类的方法

```python
#coding=utf-8
class Cat(object):
    def __init__(self,name):
        self.name = name
        self.color = 'yellow'


class Bosi(Cat):

    def __init__(self,name):
        # 调用父类的__init__方法1(python2)
        #Cat.__init__(self,name)
        # 调用父类的__init__方法2
        #super(Bosi,self).__init__(name)
        # 调用父类的__init__方法3
        super().__init__(name)

    def getName(self):
        return self.name

bosi = Bosi('xiaohua')

print(bosi.name)
print(bosi.color)
```

#### 方法的重载

子类中，有一个和父类相同名字的方法，在子类中的方法会覆盖掉父类中同名的方法 

```python
#coding=utf-8
class Cat(object):
    def sayHello(self):
        print("halou-----1")


class Bosi(Cat):

    def sayHello(self):
        print("halou-----2")

bosi = Bosi()
bosi.sayHello()
```

#### 多态

python 的鸭子模型 与java有所区别

```python
class F1(object):
    def show(self):
        print 'F1.show'

class S1(F1):

    def show(self):
        print 'S1.show'

class S2(F1):

    def show(self):
        print 'S2.show'

def Func(obj):
    print obj.show()

s1_obj = S1()
Func(s1_obj) 

s2_obj = S2()
Func(s2_obj)
```

#### 类属性（共有，私有）

```python
class People(object):
    name = 'Tom'  #公有的类属性
    __age = 12     #私有的类属性

p = People()

print(p.name)           #正确
print(People.name)      #正确
print(p.__age)            #错误，不能在类外通过实例对象访问私有的类属性
print(People.__age)        #错误，不能在类外通过类对象访问私有的类属性
```

#### 对象属性

```python
class People(object):
    address = '山东' #类属性
    def __init__(self):
        self.name = 'xiaowang' #实例属性
        self.age = 20 #实例属性

p = People()
p.age =12 #实例属性
print(p.address) #正确
print(p.name)    #正确
print(p.age)     #正确

print(People.address) #正确
print(People.name)    #错误
print(People.age)     #错误
```

#### 属性的修改（注意修改的区别）

```python
class People(object):
    country = 'china' #类属性

print(People.country)
p = People()
print(p.country)
p.country = 'japan' 
print(p.country)      #实例属性会屏蔽掉同名的类属性 这里与java不一样，这里修改会单独创建一个属性，删除后则使用类属性
print(People.country)
del p.country    #删除实例属性
print(p.country)

#结果
china
china
japan
china
china
```

- 如果需要在类外修改`类属性`，必须通过`类对象`去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的`实例属性`，这种方式修改的是`实例属性`，不会影响到`类属性`，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是`实例属性`，除非删除了该`实例属性`。

#### 类方法（使用@classmethod修饰）

```python
class People(object):
    country = 'china'

    #类方法，用classmethod来进行修饰
    @classmethod
    def getCountry(cls):
        return cls.country

    @classmethod
    def setCountry(cls,country):
        cls.country = country


p = People()
print p.getCountry()    #可以用过实例对象引用
print People.getCountry()    #可以通过类对象引用

p.setCountry('japan')   

print p.getCountry()   
print People.getCountry()

# 结果
china
china
japan
japan
```

类对象所拥有的方法，需要用修饰器`@classmethod`来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以`cls`作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以'cls'作为第一个参数的名字，就最好用'cls'了），能够通过实例对象和类对象去访问 

可以对类属性进行修改 

结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变 

#### 静态方法（@staticmethod）

通过修饰器`@staticmethod`来进行修饰，静态方法不需要多定义参数 

```python
class People(object):
    country = 'china'
    
    @staticmethod
    #静态方法
    def getCountry():
        return People.country
print People.getCountry()
```

从类方法和实例方法以及静态方法的定义形式就可以看出来，类方法的第一个参数是类对象cls，那么通过cls引用的必定是类对象的属性和方法；而实例方法的第一个参数是实例对象self，那么通过self引用的可能是类属性、也有可能是实例属性（这个需要具体分析），不过在存在相同名称的类属性和实例属性的情况下，实例属性优先级更高。静态方法中不需要额外定义参数，因此在静态方法中引用类属性的话，必须通过类对象来引用 



### 设计模式

#### 工厂模式

```python
class Car1(object):
    def move(self):
        print("--car1--move")
        
    def stop(self):
        print("--car1--stop")

class Car2(object):
	def move(self):
		print("--car2--move")
	
	def stop(self):
		print("--car2--move")
		
    
# 定义一个工厂类
class CarFactory(object):
	def createCar(self,typeName):
		if(typeName == "car1"):
			return Car1()
		elif(typeName == "car2"):
			return Car2()
    

class CarStore(object):
    def createCar(self,typeName):
        pass
    
    def order(self,typeName):
        car = self.carFactory.createCar(typeName)
    	car.move()
       	car.stop()
        
    def __init__(self):
        self.carFactory = CarFactory()
        
carStore = CarStore()
carStore.order("car1")
```

定义了一个创建对象的`接口`(可以理解为函数)，但由子类决定要实例化的类是哪一个，工厂方法模式让类的实例化推迟到子类，抽象的CarStore提供了一个创建对象的方法createCar，也叫作`工厂方法`。

子类真正实现这个createCar方法创建出具体产品。 创建者类不需要直到实际创建的产品是哪一个，选择了使用了哪个子类，自然也就决定了实际创建的产品是什么

#### 单例模式

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。 

```python
class Singleton(object):
    __instance = None # 定义一个私有类属性，在创建的时候初始化
    __first_init = False # 定义初始化开关，保证只能初始化一次
    
    def __new__(cls,age,name): # 保证只有一个对象
        if not cls.__instance: # 如果对象没有被定义，那么这个对象就创建一次
            cls.__instance = object.__new__(cls)
        return cls.__instance
    
    del __init__(self,age,name):
        if not __first_init:
           	self.age = age;
            self.name = name;
            Singleton.__first_init = True
        
a = Singleton(11,"ss")
b = Singleton(12,"ss2") # 初始化一次，再次初始化就无效了
print(id(a))
print(id(b))

a.age = 19
print(b.age)
```

#### 异常

```python
try:
    pass
except (IOError,NameError): # 可以捕获多个异常
    print(errorMsg) # errorMsg中会有异常信息
finally:
    pass # try结束后必须执行 用于释放资源，连接，锁等
```

将捕获 异常存储在元组中

```python
try:
    pass
except (NameError,IOError) as result:
    print(result)
```

捕获所有异常

```python
try:
    pass
except Exception as result:
    print(result)
```

使用else进行判断异常

```python
try:
    pass
except NameError as errorMsg:
    print(errorMsg)
else:
    print("没有捕获到NameError异常")
```

#### 自定义异常

需要是Exception的子类，使用raise关键字抛出

```python
class ShortInputException(Exception):
    '''自定义的异常类'''
    def __init__(self, length, atleast):
        super().__init__()
        self.length = length
        self.atleast = atleast

def main():
    try:
        s = input('请输入 --> ')
        if len(s) < 3:
            # raise引发一个你定义的异常
            raise ShortInputException(len(s), 3)
    except ShortInputException as result:#x这个变量被绑定到了错误的实例
        print('ShortInputException: 输入的长度是 %d,长度至少应是 %d'% (result.length, result.atleast))
    else:
        print('没有异常发生.')

main()
```

注意：以上程序中，关于代码

```
#super().__init__()
```

的说明

> 这一行代码，可以调用也可以不调用，建议调用，因为`__init__`方法往往是用来对创建完的对象进行初始化工作，如果在子类中重写了父类的`__init__`方法，即意味着父类中的很多初始化工作没有做，这样就不保证程序的稳定了，所以在以后的开发中，如果重写了父类的`__init__`方法，最好是先调用父类的这个方法，然后再添加自己的功能

### 模块

类比于java的包，使用import关键字导入

```python
import module1,mudule2...

import test

result = test.add(11,22)
print(result)
```

当一个方法在多个模块中重名，那么使用`模块名.函数名`进行调用

在python中，每个py文件就是一个模块，文件名称就是模块的名称

#### `__name__`属性

在每个py文件中，有一个`__name__` 属性，如果值是`__main__`表示是本模块调用

如果不是，表示其他模块引用调用，通过该属性，可以执行本模块特定非引用执行的功能，如测试代码

#### `__all__`属性

有该属性的模块，在被其他模块引用时（使用from 文件夹名称 import * 导入时，该导入不用填写模块名可以直接调用方法）不在该all中的，那么无法使用，用于忽略其他调用，只能使用all中的定义

```python
__all__=["类名"，"函数名"，"变量名"]
```

#### 导包（含有`__init__.py`文件的为包）

使用 import 文件.模块 的方式

```python
msg
|__ test1.py
|__ test2.py

import msg.test1
import msg.test2

msg.test1.hello()
msg.test2.hello()
```

使用 from 文件夹 import 模块 的方式

注意：需要添加`__init__.py` 文件下面的方式才能执行

在`__init__.py`文件中添加

```py
__all__ = ["test1","test2"] 
```

```python
from msg import *
test1.hello()
test2.hello()
```

#### `__init__.py`的作用

控制包的导入行为

定义一个`__all__`文件，控制着from 包名 import *  时导入的模块

如果在init 的py文件中编写python执行，也是会被执行

其中init文件的方法调用不是使用 包名.模块.函数 而是 包名.函数

```
Phone/
    __init__.py
    common_util.py
    Voicedta/
        __init__.py
        Pots.py
        Isdn.py
    Fax/
        __init__.py
        G3.py
    Mobile/
        __init__.py
        Analog.py
        igital.py
    Pager/
        __init__.py
        Numeric.py
```

```python
import Phone.Mobile.Analog
Phone.Mobile.Analog.dial()

from Phone import Mobile
Mobile.Analog.dial('555-1212')

from Phone.Mobile import Analog
Analog.dial('555-1212')

from Phone.Mobile.Analog import dial
dial('555-1212')
```

#### 发布

目录结构

```
.
├── setup.py
├── suba
│   ├── aa.py
│   ├── bb.py
│   └── __init__.py
└── subb
    ├── cc.py
    ├── dd.py
    └── __init__.py
```

第一步：在要发布的包下创建setup.py文件 文件内容如下

```python
from distutils.core import setup

setup(name="dongGe", version="1.0", description="dongGe's module", author="dongGe", py_modules=['suba.aa', 'suba.bb', 'subb.cc', 'subb.dd'])
```

第二步：构建模块

```python
python setup.py build
```

构建后的目录

```
.
├── build
│   └── lib.linux-i686-2.7
│       ├── suba
│       │   ├── aa.py
│       │   ├── bb.py
│       │   └── __init__.py
│       └── subb
│           ├── cc.py
│           ├── dd.py
│           └── __init__.py
├── setup.py
├── suba
│   ├── aa.py
│   ├── bb.py
│   └── __init__.py
└── subb
    ├── cc.py
    ├── dd.py
    └── __init__.py
```

第三步：发布成压缩包

```python
python step.py sdist
```

结果目录

```
.
├── build
│   └── lib.linux-i686-2.7
│       ├── suba
│       │   ├── aa.py
│       │   ├── bb.py
│       │   └── __init__.py
│       └── subb
│           ├── cc.py
│           ├── dd.py
│           └── __init__.py
├── dist
│   └── dongGe-1.0.tar.gz
├── MANIFEST
├── setup.py
├── suba
│   ├── aa.py
│   ├── bb.py
│   └── __init__.py
└── subb
    ├── cc.py
    ├── dd.py
    └── __init__.py
```



#### 安装模块与使用

包的调用，现在本地寻找，本地没有则去python安装的目录下查找，没有则在usr/lib/python 下查找

解压压缩包，执行命令

```python
python setup.py install
如果没有权限则使用
sudo python steup.py install 进行安装
```

- 如果在install的时候，执行目录安装，可以使用`python setup.py install --prefix=安装路径`

 在程序中，使用from import 即可完成对安装的模块使用

`from 模块名 import 模块名或者*`

### 其他

#### 给执行的py文件传递参数

通过引入sys模块，并且通过sys.argv 进行获取 ，注意打印的是一个参数数组，第一个参数是文件名

```python
import sys
print(sys.argv)

name = sys.argv[1]

# 结果
['05.sys-argv.py', 'a', 'b', 'c', 'd', 'e']
```



### 列表推导式

轻量级的循环创建列表

应用场景：生成数组

使用while循环创建

```python
a = []
i = 0
while i < 100:
    a.append(i)
    i += 1
   
print(a)
```

使用for循环创建

```python
a = []
for i in range(0,100):
    a.append(i)
    
print(a)
#使用range(100)表示的是[0,100)范围的数字的列表
#使用range(10,100)则是[10,100)
#range(10,100,3) 其中的3是步长                
```

range的风险：

- 在python2中有风险，因为声明之后会在内存中开辟一块区域用于存储range生成的数组，那么range可定义过大的话，则会造成内存的溢出
- 在python3中规避了该风险

使用列表推导方式

```python
a = [i for i in range(0,100)]
```

关于列表生成式

```python
b = [22 for i in range(0,10)]
# 结果是 10个22
# 说明 for 每次执行一下，在数组中添加一个22 如果是i 则将当前的i值添加进去
```

扩展

在推导式中添加if判断

```python
c = [i for i in range(10) if i%2 == 0]
#结果 [0, 2, 4, 6, 8]
```

在推导式中使用多个for

```python
d = [i for i in range(3) for j in range(2)]
# result : [0, 0, 1, 1, 2, 2] 
# 等价于双层for循环 里面的子for 决定了每个元素执行的次数
# 如果要将j也打印出来 这里需要用() 包裹
e = [(i,j) for i in range(3) for j in range(2)]
# 结果： [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]
# d = [] 
# for i in range(3):
# 	for j in range(2):
# 		d.append(i)
```



### 练习

面向对象练习，射击类

#### 安装pygame模块

首先安装类库 pygame 用于编写游戏界面的工具类库，使用pip命令进行安装，pip类似于npm 

```python
pip install pygame
pip3 install pygame
```

输入命令后，会自动去下载相应的类库。注意：pip默认是python2的安装 pip3是python3的安装

#### 更新pip模块

要有相应的权限，sudo -s 进入root管理员

```python
pip install --upgrade pip
# 如果安装了pip3 则系统默认是pip3 此时如需要pip使用，那么需要使用pip2 install 进行下载操作
pip3 install --upgrade pip
```



#### 编写模块

##### 窗口模块

main.py

注意编码格式使用utf-8

```python
# -*- coding:utf-8 -*-
import pygame
import time

def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	
	while True:
		screen.blit(background,(0,0))
		pygame.display.update()
		time.sleep(0.01)

if __name__ == "__main__":
	main()
```

原理：显示一个窗口，不断的刷新窗口的显示，使用while True和time 为100ms间隔进行刷新窗口操作，显示窗口的变化

使用pygame固定方式生成窗口



##### 显示飞机并移动（键盘事件）

````python
#coding=utf-8
import pygame
from pygame.locals import *
import time

def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	# 显示飞机	
	hero = pygame.image.load("./resource/hero.gif")

	hero_x = 210
	hero_y = 700	

	while True:
		screen.blit(background,(0,0))
		
		# 获取键盘事件
		for event in pygame.event.get():
			
			# 判断是否按下退出按键
			if event.type == QUIT:
				exit()
			elif event.type == KEYDOWN:#检测按下了按键
				if event.key == K_a or event.key == K_LEFT:
					print("left")
					hero_x -= 5
				elif event.key == K_d or event.key == K_RIGHT:
					print("right")
					hero_x += 5
				elif event.key == K_w or event.key == K_UP:
					hero_y -= 5
				elif event.key == K_s or event.key == K_DOWN:
					hero_y += 5
				elif event.key == K_SPACE:
					print("space")
		
		# 显示飞机
		screen.blit(hero,(hero_x,hero_y))

		pygame.display.update()
		time.sleep(0.01)

if __name__ == "__main__":
	main()
````



面向对象实现

```python
#coding=utf-8
import pygame
from pygame.locals import *
import time

# 定义一个飞机的类
class HeroPlan(object):
	def __init__(self,screen):
		self.screen = screen
		# 定义初始坐标		
		self.x = 230
		self.y = 600
		# 定义飞机图片		
		self.imageName = "./resource/hero.gif"
		self.image = pygame.image.load(self.imageName).convert()
		# 保存发射的子弹
		self.bullet = []
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
	
	def moveLeft(self):
		self.x -= 10
	
	def moveRight(self):
		self.x += 10

	def moveUp(self):
		self.y -= 10
	
	def moveDown(self):
		self.y += 10

	def shoot(self):
		pass

def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	heroPlan = HeroPlan(screen)
	while True:
		screen.blit(background,(0,0))
		heroPlan.display()
		
		# 获取键盘事件
		for event in pygame.event.get():
			
			# 判断是否按下退出按键
			if event.type == QUIT:
				exit()
			elif event.type == KEYDOWN:#检测按下了按键
				if event.key == K_a or event.key == K_LEFT:
					heroPlan.moveLeft()
				elif event.key == K_d or event.key == K_RIGHT:
					heroPlan.moveRight()
				elif event.key == K_w or event.key == K_UP:
					heroPlan.moveUp()
				elif event.key == K_s or event.key == K_DOWN:
					heroPlan.moveDown()
				elif event.key == K_SPACE:
					heroPlan.shoot()
		
		pygame.display.update()
		time.sleep(0.01)

if __name__ == "__main__":
	main()
```

##### 实现射击

```python
#coding=utf-8
import pygame
from pygame.locals import *
import time

# 定义一个飞机的类
class HeroPlan(object):
	def __init__(self,screen):
		self.screen = screen
		# 定义初始坐标		
		self.x = 230
		self.y = 600
		# 定义飞机图片		
		self.imageName = "./resource/hero.gif"
		self.image = pygame.image.load(self.imageName).convert()
		# 保存发射的子弹
		self.bullets = []
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		# 循环所有子弹进行显示
		for bullet in self.bullets:
			bullet.display()
		
	def moveLeft(self):
		self.x -= 10
	
	def moveRight(self):
		self.x += 10

	def moveUp(self):
		self.y -= 10
	
	def moveDown(self):
		self.y += 10

	def shoot(self):
		# 每次射击生产一个子弹
		newBullet = Bullet(self.x,self.y,self.screen)
		self.bullets.append(newBullet)


# 定义子弹类
class Bullet(object):
	def __init__(self,x,y,screen):
		# 传入坐标是飞机的左上角xy 需要进行一定的处理子弹在飞机的正上方显示
		self.x = x+40
		self.y = y-20
		self.screen = screen
		self.image = pygame.image.load("./resource/bullet-3.gif").convert();
		
	def move(self):
		# 子弹的移动是垂直向上的
		self.y -= 2
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		self.move()

def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	
	heroPlan = HeroPlan(screen)

	while True:
		screen.blit(background,(0,0))
		heroPlan.display()
		
		# 获取键盘事件
		for event in pygame.event.get():
			
			# 判断是否按下退出按键
			if event.type == QUIT:
				exit()
			elif event.type == KEYDOWN:#检测按下了按键
				if event.key == K_a or event.key == K_LEFT:
					heroPlan.moveLeft()
				elif event.key == K_d or event.key == K_RIGHT:
					heroPlan.moveRight()
				elif event.key == K_w or event.key == K_UP:
					heroPlan.moveUp()
				elif event.key == K_s or event.key == K_DOWN:
					heroPlan.moveDown()
				elif event.key == K_SPACE:
					heroPlan.shoot()
		
		pygame.display.update()
		time.sleep(0.01)

if __name__ == "__main__":
	main()
```

##### 显示敌机

```python
#coding=utf-8
import pygame
from pygame.locals import *
import time
import random 


# 定义一个飞机的类
class HeroPlane(object):
	def __init__(self,screen):
		self.screen = screen
		# 定义初始坐标		
		self.x = 230
		self.y = 600
		# 定义飞机图片		
		self.imageName = "./resource/hero.gif"
		self.image = pygame.image.load(self.imageName).convert()
		# 保存发射的子弹
		self.bullets = []
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		
		# 删除所有失效的子弹
		deleteBullets = []
		for bullet in self.bullets:
			if(bullet.judge()):
				deleteBullets.append(bullet)

		for dBullet in deleteBullets:
			self.bullets.remove(dBullet)
		
		# 循环所有子弹进行显示
		for bullet in self.bullets:
			bullet.display()
			
	def moveLeft(self):
		self.x -= 10
	
	def moveRight(self):
		self.x += 10

	def moveUp(self):
		self.y -= 10
	
	def moveDown(self):
		self.y += 10

	def shoot(self):
		# 每次射击生产一个子弹
		newBullet = Bullet(self.x,self.y,self.screen)
		self.bullets.append(newBullet)

# 定义子弹类
class Bullet(object):
	def __init__(self,x,y,screen):
		# 传入坐标是飞机的左上角xy 需要进行一定的处理子弹在飞机的正上方显示
		self.x = x+40
		self.y = y-20
		self.screen = screen
		self.image = pygame.image.load("./resource/bullet-3.gif").convert();
		
	def move(self):
		# 子弹的移动是垂直向上的
		self.y -= 2
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		self.move()
		
	def judge(self):
		return self.y < 0

# 定义敌机
class EnemyPlane(object):
	def __init__(self,screen):
		self.x = 0
		self.y = 0
		self.screen = screen
		self.imageName = "./resource/enemy-1.gif"
		self.image = pygame.image.load(self.imageName).convert()
		self.bullets = []
		# 定义敌机的运动方向
		self.direction = "right"		
		

	def display(self):
		self.screen.blit(self.image,(self.x,self.y))		
		self.move()		
		# 删除所有失效的子弹
		deleteBullets = []
		for bullet in self.bullets:
			if(bullet.judge()):
				deleteBullets.append(bullet)

		for dBullet in deleteBullets:
			self.bullets.remove(dBullet)
		
		# 循环所有子弹进行显示
		for bullet in self.bullets:
			bullet.display()		

	def move(self):
		# 如果碰到了边界则向反方向移动
		if self.direction == "right":
			self.x += 2
		elif self.direction == "left":
			self.x -= 2

		if self.x > 480 - 50:
			self.direction = "left"
		elif self.x < 0:
			self.direction = "right"
		
def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	
	heroPlane = HeroPlane(screen)
	enemyPlane = EnemyPlane(screen)

	while True:
		screen.blit(background,(0,0))
		heroPlane.display()
		enemyPlane.display()
		
		# 获取键盘事件
		for event in pygame.event.get():
			
			# 判断是否按下退出按键
			if event.type == QUIT:
				exit()
			elif event.type == KEYDOWN:#检测按下了按键
				if event.key == K_a or event.key == K_LEFT:
					heroPlane.moveLeft()
				elif event.key == K_d or event.key == K_RIGHT:
					heroPlane.moveRight()
				elif event.key == K_w or event.key == K_UP:
					heroPlane.moveUp()
				elif event.key == K_s or event.key == K_DOWN:
					heroPlane.moveDown()
				elif event.key == K_SPACE:
					heroPlane.shoot()
		
		pygame.display.update()
		# 用于降低cpu的占用率
		time.sleep(0.01)

if __name__ == "__main__":
	main()
```

##### 敌机发射子弹

重点：发射子弹需要一个随机数

```python
#coding=utf-8
import pygame
from pygame.locals import *
import time
import random 

# 定义一个飞机的类
class HeroPlane(object):
	def __init__(self,screen):
		self.screen = screen
		# 定义初始坐标		
		self.x = 230
		self.y = 600
		# 定义飞机图片		
		self.imageName = "./resource/hero.gif"
		self.image = pygame.image.load(self.imageName).convert()
		# 保存发射的子弹
		self.bullets = []
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		
		# 删除所有失效的子弹
		deleteBullets = []
		for bullet in self.bullets:
			if(bullet.judge()):
				deleteBullets.append(bullet)

		for dBullet in deleteBullets:
			self.bullets.remove(dBullet)
		
		# 循环所有子弹进行显示
		for bullet in self.bullets:
			bullet.display()
		
	def moveLeft(self):
		self.x -= 10
	
	def moveRight(self):
		self.x += 10

	def moveUp(self):
		self.y -= 10
	
	def moveDown(self):
		self.y += 10

	def shoot(self):
		# 每次射击生产一个子弹
		newBullet = Bullet(self.x,self.y,self.screen)
		self.bullets.append(newBullet)

	
# 定义子弹类
class Bullet(object):
	def __init__(self,x,y,screen):
		# 传入坐标是飞机的左上角xy 需要进行一定的处理子弹在飞机的正上方显示
		self.x = x+40
		self.y = y-20
		self.screen = screen
		self.image = pygame.image.load("./resource/bullet-3.gif").convert();
		
	def move(self):
		# 子弹的移动是垂直向上的
		self.y -= 2
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		self.move()
		
	def judge(self):
		return self.y < 0

# 定义敌机
class EnemyPlane(object):
	def __init__(self,screen):
		self.x = 0
		self.y = 0
		self.screen = screen
		self.imageName = "./resource/enemy-1.gif"
		self.image = pygame.image.load(self.imageName).convert()
		self.bullets = []
		# 定义敌机的运动方向
		self.direction = "right"		
		

	def display(self):
		self.screen.blit(self.image,(self.x,self.y))		
		self.move()
		self.shoot()		
		# 删除所有失效的子弹
		deleteBullets = []
		for bullet in self.bullets:
			if(bullet.judge()):
				deleteBullets.append(bullet)

		for dBullet in deleteBullets:
			self.bullets.remove(dBullet)
		
		# 循环所有子弹进行显示
		for bullet in self.bullets:
			bullet.display()		

	def move(self):
		# 如果碰到了边界则向反方向移动
		if self.direction == "right":
			self.x += 2
		elif self.direction == "left":
			self.x -= 2

		if self.x > 480 - 50:
			self.direction = "left"
		elif self.x < 0:
			self.direction = "right"

	def shoot(self):
		num = random.randint(1,200)
		if num == 33 or num == 133:
			print(num)
			# 每次射击生产一个子弹
			newBullet = EnemyBullet(self.x,self.y,self.screen)
			self.bullets.append(newBullet)
		

class EnemyBullet(object):
	def __init__(self,x,y,screen):
		self.x = x + 30
		self.y = y + 30
		self.screen = screen
		self.image = pygame.image.load("./resource/bullet-1.gif").convert()
	
	def move(self):
		self.y += 2

	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		self.move()

	def judge(self):
		return self.y > 890
	
def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	
	heroPlane = HeroPlane(screen)
	enemyPlane = EnemyPlane(screen)

	while True:
		screen.blit(background,(0,0))
		heroPlane.display()
		enemyPlane.display()
		
		# 获取键盘事件
		for event in pygame.event.get():
			
			# 判断是否按下退出按键
			if event.type == QUIT:
				exit()
			elif event.type == KEYDOWN:#检测按下了按键
				if event.key == K_a or event.key == K_LEFT:
					heroPlane.moveLeft()
				elif event.key == K_d or event.key == K_RIGHT:
					heroPlane.moveRight()
				elif event.key == K_w or event.key == K_UP:
					heroPlane.moveUp()
				elif event.key == K_s or event.key == K_DOWN:
					heroPlane.moveDown()
				elif event.key == K_SPACE:
					heroPlane.shoot()
		
		pygame.display.update()
		# 用于降低cpu的占用率
		time.sleep(0.01)

if __name__ == "__main__":
	main()
```

##### 代码优化：抽取基类

```python
#coding=utf-8
import pygame
from pygame.locals import *
import time
import random 

# 定义一个图形的基类
class Base(object):
	def __init__(self,screen,name):
		self.name = name
		self.screen = screen
	

class Plane(Base):
	def __init__(self,screen,name,imageName,x,y):
		super().__init__(screen,name)
		self.x = x
		self.y = y
		self.image = pygame.image.load(imageName).convert()
		# 用来存储子弹
		self.bullets = []
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		#删除不满足条件的子弹
		deleteBullets = []
		for i in self.bullets:
			if i.judge():
				deleteBullets.append(i)
			
		for i in deleteBullets:
			self.bullets.remove(i)
		
		#更新显示子弹
		for i in self.bullets:
			i.display()

	def shoot(self):
		newBullet = BaseBullet(self.x,self.y,self.screen,self.name)
		self.bullets.append(newBullet)

#定义子弹
class BaseBullet(Base):
	def __init__(self,x,y,screen,planeName):
		super().__init__(screen,planeName)
		if self.name == "hero":
			self.x = x + 40
			self.y = y - 20
			imageName = "./resource/bullet-3.gif"
		elif self.name == "enemy":
			self.x = x + 30
			self.y = y + 30
			imageName = "./resource/bullet-1.gif"

		self.image = pygame.image.load(imageName).convert()
	
	def move(self):
		if self.name == "hero":
			self.y -= 2
		elif self.name == "enemy":
			self.y += 2
	
	def display(self):
		self.screen.blit(self.image,(self.x,self.y))
		self.move()
	
	def judge(self):
		return self.y > 890 or self.y < 0	


# 定义一个飞机的类
class HeroPlane(Plane):
	def __init__(self,screen):
		super().__init__(screen,"hero","./resource/hero.gif",230,600)		

			
	def moveLeft(self):
		self.x -= 10
	
	def moveRight(self):
		self.x += 10

	def moveUp(self):
		self.y -= 10
	
	def moveDown(self):
		self.y += 10

	
# 定义敌机
class EnemyPlane(Plane):
	def __init__(self,screen):
		super().__init__(screen,"enemy","./resource/enemy-1.gif",0,0)
		# 定义敌机的运动方向
		self.direction = "right"

	def display(self):
		super().display()
		self.move()
		self.shoot()		
			

	def move(self):
		# 如果碰到了边界则向反方向移动
		if self.direction == "right":
			self.x += 2
		elif self.direction == "left":
			self.x -= 2

		if self.x > 480 - 50:
			self.direction = "left"
		elif self.x < 0:
			self.direction = "right"

	def shoot(self):
		num = random.randint(1,200)
		if num == 33 or num == 133:
			super().shoot()
		
	
def main():
	# 创建窗口
	screen = pygame.display.set_mode((480,852),0,32)
	# 添加背景图片
	background = pygame.image.load("./resource/background.png")
	
	heroPlane = HeroPlane(screen)
	enemyPlane = EnemyPlane(screen)

	while True:
		screen.blit(background,(0,0))
		heroPlane.display()
		enemyPlane.display()
		
		# 获取键盘事件
		for event in pygame.event.get():
			
			# 判断是否按下退出按键
			if event.type == QUIT:
				exit()
			elif event.type == KEYDOWN:#检测按下了按键
				if event.key == K_a or event.key == K_LEFT:
					heroPlane.moveLeft()
				elif event.key == K_d or event.key == K_RIGHT:
					heroPlane.moveRight()
				elif event.key == K_w or event.key == K_UP:
					heroPlane.moveUp()
				elif event.key == K_s or event.key == K_DOWN:
					heroPlane.moveDown()
				elif event.key == K_SPACE:
					heroPlane.shoot()
		
		pygame.display.update()
		# 用于降低cpu的占用率
		time.sleep(0.01)

if __name__ == "__main__":
	main()
```

##### 扩展：飞机爆炸

```python
# -*- coding:utf-8 -*-
import pygame
from pygame.locals import *
import time

'''
说明
1.按下b键,让玩家飞机爆炸 
2.爆炸效果的原理是:换图片
'''

class Hero(object):
    def __init__(self, screen_temp):
        self.x = 210
        self.y = 700
        self.image = pygame.image.load("./feiji/hero1.png")
        self.screen = screen_temp
        self.bullet_list = []#用来存储子弹对象的引用

        #爆炸效果用的如下属性
        self.hit = False #表示是否要爆炸
        self.bomb_list = [] #用来存储爆炸时需要的图片
        self.__crate_images() #调用这个方法向bomb_list中添加图片
        self.image_num = 0#用来记录while True的次数,当次数达到一定值时才显示一张爆炸的图,然后清空,,当这个次数再次达到时,再显示下一个爆炸效果的图片
        self.image_index = 0#用来记录当前要显示的爆炸效果的图片的序号

    def __crate_images(self):
        self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n1.png"))
        self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n2.png"))
        self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n3.png"))
        self.bomb_list.append(pygame.image.load("./feiji/hero_blowup_n4.png"))

    def display(self):
        """显示玩家的飞机"""
        #如果被击中,就显示爆炸效果,否则显示普通的飞机效果
        if self.hit == True:
            self.screen.blit(self.bomb_list[self.image_index], (self.x, self.y))
            self.image_num+=1
            if self.image_num == 7:
                self.image_num=0
                self.image_index+=1
            if self.image_index>3:
                time.sleep(1)
                exit()#调用exit让游戏退出
                #self.image_index = 0
        else:
            self.screen.blit(self.image,(self.x, self.y))

        #不管玩家飞机是否被击中,都要显示发射出去的子弹
        for bullet in self.bullet_list:
            bullet.display()
            bullet.move()

    def move_left(self):
        self.x -= 8

    def move_right(self):
        self.x += 8

    def fire(self):
        """通过创建一个子弹对象,完成发射子弹"""
        print("-----1----")
        bullet = Bullet(self.screen, self.x, self.y)#创建一个子弹对象
        self.bullet_list.append(bullet)

    def bomb(self):
        self.hit = True

class Bullet(object):
    def __init__(self, screen_temp, x_temp, y_temp):
        self.x = x_temp+40
        self.y = y_temp-20
        self.image = pygame.image.load("./feiji/bullet.png")
        self.screen = screen_temp
        
    def display(self):
        self.screen.blit(self.image, (self.x, self.y))

    def move(self):
        self.y -= 4

class EnemyPlane(object):
    def __init__(self, screen_temp):
        self.x = 0
        self.y = 0
        self.image = pygame.image.load("./feiji/enemy0.png")
        self.screen = screen_temp
        #self.bullet_list = []#用来存储子弹对象的引用
        self.direction = "right"#用来设置这个飞机默认的移动方向

    def display(self):
        """显示敌人的飞机"""
        self.screen.blit(self.image,(self.x, self.y))

    def move(self):


        if self.direction == "right":
            self.x+=2
        elif self.direction == "left":
            self.x-=2

        if self.x>480-50:
            self.direction="left"
        elif self.x<0:
            self.direction="right"

def key_control(hero_temp):
    #获取事件，比如按键等
    for event in pygame.event.get():

        #判断是否是点击了退出按钮
        if event.type == QUIT:
            print("exit")
            exit()
        #判断是否是按下了键
        elif event.type == KEYDOWN:
            #检测按键是否是a或者left
            if event.key == K_a or event.key == K_LEFT:
                print('left')
                hero_temp.move_left()

            #检测按键是否是d或者right
            elif event.key == K_d or event.key == K_RIGHT:
                print('right')
                hero_temp.move_right()

            #检测按键是否是空格键
            elif event.key == K_SPACE:
                print('space')
                hero_temp.fire()
            elif event.key == K_b:
                print('b')
                hero_temp.bomb()

def main():
    screen = pygame.display.set_mode((480,852),0,32)
    background = pygame.image.load("./feiji/background.png")

    #创建玩家飞机
    hero = Hero(screen)

    #创建敌机
    enemy = EnemyPlane(screen)

    while True:
        screen.blit(background,(0,0))
        hero.display()
        enemy.display()
        enemy.move()
        pygame.display.update()
        key_control(hero)
       
if __name__ == "__main__":
    main()
```





